<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Prompt Generator & Manager (Sincronizado)</title>
    <style>
        * { box-sizing: border-box; }

        :root {
            --bg: #121212;
            --surface: #1e1e1e;
            --primary: #bb86fc;
            --text: #e0e0e0;
            --border: #333;
            --accent-active: #2196F3;
            --danger: #cf6679;
            --saved-word: #ff69b4; /* Rosa para palabras guardadas */
        }

        body {
            font-family: 'Segoe UI', monospace, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0; padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
            width: 100%;
        }

        /* Contenedor Principal */
        #generator-container {
            width: 100%;
            max-width: none;
            background: var(--surface);
            padding: 20px;
            margin: 0;
            border-bottom: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .hidden { display: none !important; }
        h2 { margin-top: 0; color: var(--primary); text-align: center; }

        /* Switch Styles */
        .switch-wrapper { display: flex; align-items: center; justify-content: center; margin-bottom: 20px; gap: 15px; font-weight: bold; font-size: 0.9em; }
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent-active); }
        input:checked + .slider:before { transform: translateX(26px); }
        .mode-label { opacity: 0.5; transition: 0.3s; color: #aaa; }
        .mode-label.active { opacity: 1; color: white; font-weight: bold; }

        .grid-container { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: 0.9em; color: #aaa; }
        input, select, textarea { width: 100%; background: #2d2d2d; border: 1px solid var(--border); color: white; padding: 10px; border-radius: 4px; outline: none; }

        /* Botones */
        .btn-group { display: flex; gap: 10px; margin-top: 20px; }
        button { flex: 1; padding: 12px; cursor: pointer; font-weight: bold; border: none; border-radius: 4px; transition: background 0.2s; }
        #btn-generate { background-color: var(--primary); color: #000; }
        #btn-generate:hover { background-color: #a370db; }
        #btn-paste { background-color: #03dac6; color: #000; }
        #btn-paste:hover { background-color: #01b4a4; }
        #btn-show-gen { background-color: #333; color: #fff; margin: 0; padding: 15px; display: none; width: 100%; border-radius: 0; }

        /* Output Area */
        #prompt-output { margin-top: 20px; background: #000; padding: 15px; border: 1px solid var(--primary); font-family: monospace; white-space: pre-wrap; display: none; }

        /* Resultados Accordion */
        #results-container { width: 100%; padding: 20px; }
        .accordion-item { background: var(--surface); border: 1px solid var(--border); margin-bottom: 10px; border-radius: 4px; overflow: hidden; }
        .accordion-header { padding: 15px; background: #252525; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .accordion-header:hover { background: #303030; }
        .header-content { display: flex; flex-direction: column; gap: 4px; }
        .header-actions { display: flex; align-items: center; gap: 15px; }
        
        .btn-delete { background: transparent; color: #666; border: 1px solid #444; padding: 5px 10px; border-radius: 4px; flex: none; font-size: 1.2em; line-height: 1; }
        .btn-delete:hover { background: var(--danger); color: white; border-color: var(--danger); }

        .accordion-content { padding: 15px; display: none; border-top: 1px solid var(--border); font-size: 0.95em; line-height: 1.6; }
        .accordion-content.active { display: block; }

        .meta-tag { background: #333; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; display: inline-block; width: fit-content; }
        .copy-prompt-btn { background: var(--primary); color: black; border: none; padding: 5px 10px; font-size: 0.8em; border-radius: 4px; cursor: pointer; margin-bottom: 10px; display: inline-block; width: auto; flex: none; }

        /* Estilos para palabras interactivas */
        .interactive-word {
            cursor: pointer;
            border-bottom: 1px solid transparent;
            transition: all 0.2s;
            padding: 0 2px;
        }
        .interactive-word:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        /* Clase clave para la persistencia visual */
        .interactive-word.saved {
            color: var(--saved-word);
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 105, 180, 0.3);
        }
    </style>
</head>
<body>

    <button id="btn-show-gen" onclick="toggleGenerator(true)">‚ûï New Generation</button>

    <div id="generator-container">
        <h2>Nexus Prompt Engineer</h2>
        
        <div class="switch-wrapper">
            <span id="labelSimple" class="mode-label active">SIMPLE</span>
            <label class="switch">
                <input type="checkbox" id="modeSwitch" onchange="toggleAlgorithmMode()">
                <span class="slider"></span>
            </label>
            <span id="labelComplex" class="mode-label">COMPLEX</span>
        </div>
        <div class="grid-container">
            <div>
                <label>Context</label>
                <input type="text" id="contextInput" list="context-history" placeholder="Ex: React, Finance...">
                <datalist id="context-history"></datalist>
            </div>
            <div>
                <label>Specific Topic</label>
                <input type="text" id="topicInput" list="topic-history" placeholder="Ex: Hooks, ROI...">
                <datalist id="topic-history"></datalist>
            </div>

            <div><label>Mode</label><select id="modeSelect"></select></div>
            <div><label>Format</label><select id="formatSelect"></select></div>
            
            <div><label>Task Type</label><select id="taskSelect"></select></div>
            <div><label>Voice/Tone</label><select id="voiceSelect"></select></div>
            <div><label>Length</label><select id="lengthSelect"></select></div>
            <div><label>Depth Level</label><select id="levelSelect"></select></div>
        </div>

        <div class="btn-group">
            <button id="btn-generate" onclick="generatePrompt()">‚ö° Generate Prompt</button>
            <button id="btn-paste" onclick="handlePasteResponse()">üìã Paste Response & Hide</button>
        </div>

        <div id="prompt-output"></div>
    </div>

    <div id="results-container"></div>

<script>
/* =========================================
   1. CONFIG DATA
   ========================================= */
const COMMON_DATA = {
    MODES: [
        { id: 'tech', label: 'TECHNICAL', role: 'Act as a Senior Engineer.', style: 'Cyberpunk/Terminal style.', goal: 'Technical accuracy and implementation detail.' },
        { id: 'art', label: 'ART', role: 'Act as a Creative Director.', style: 'Minimalist Gallery / Editorial style.', goal: 'Aesthetic refinement and originality.' },
        { id: 'school', label: 'SCHOOL', role: 'Act as a Professor.', style: 'Clean Textbook / Academic style.', goal: 'Structured education and conceptual clarity.' },
        { id: 'story', label: 'STORYTELLING', role: 'Act as a Master Novelist.', style: 'Cinematic, immersive narrative tone.', goal: 'Engaging storytelling and world-building.' },
        { id: 'marketing', label: 'MARKETING', role: 'Act as a Senior Copywriter.', style: 'Persuasive, high-conversion writing.', goal: 'Brand voice alignment & audience engagement.' },
        { id: 'business', label: 'BUSINESS', role: 'Act as a Strategy Consultant.', style: 'Executive brief style.', goal: 'Clarity, precision, and actionable insights.' },
        { id: 'research', label: 'RESEARCH', role: 'Act as a Research Scientist.', style: 'Peer-reviewed academic tone.', goal: 'Evidence-based rigor with citations when relevant.' },
        { id: 'casual', label: 'CASUAL', role: 'Act as a friendly assistant.', style: 'Conversational, natural tone.', goal: 'Clarity, simplicity, and a human-sounding delivery.' }
    ],
    FORMATS: [
        { id: 'html', label: 'HTML APP', instruction: 'Return a single HTML5 file with inline CSS/JS. No external files. Use overflow-y:auto.' },
        { id: 'text', label: 'TEXT GUIDE', instruction: 'Return Markdown text with clear headings and structure.' },
        { id: 'code', label: 'CODE SNIPPET', instruction: 'Return raw code only with comments.' },
        { id: 'essay', label: 'ESSAY', instruction: 'Return a polished formal essay.' },
        { id: 'dialogue', label: 'DIALOGUE', instruction: 'Return a scripted scene or conversation.' },
        { id: 'template', label: 'TEMPLATE', instruction: 'Return a reusable structured template with fillable fields.' },
        { id: 'checklist', label: 'CHECKLIST', instruction: 'Return a concise actionable checklist or SOP.' }
    ]
};

const ALGORITHMS = {
    SIMPLEX: {
        TASK_TYPES: [
            { id: 'explain', label: 'EXPLANATION', instruction: 'Explain the topic clearly and step-by-step.' },
            { id: 'analysis', label: 'ANALYSIS', instruction: 'Break the topic down into components with pros, cons, variables.' },
            { id: 'create', label: 'CREATIVE GENERATION', instruction: 'Generate original content in the selected style.' },
            { id: 'teach', label: 'TEACHING', instruction: 'Introduce, teach, give examples, and add a practice checkpoint.' },
            { id: 'improve', label: 'IMPROVEMENT', instruction: 'Rewrite and enhance the user‚Äôs content with better clarity and style.' },
            { id: 'compare', label: 'COMPARISON', instruction: 'Compare items using structure, criteria, and reasoning.' },
            { id: 'build', label: 'CONSTRUCTION', instruction: 'Produce a structured artifact: plan, blueprint, script, architecture, or framework.' }
        ],
        VOICES: [
            { id: 'neutral', label: 'Neutral', instruction: 'Use a balanced, neutral tone.' },
            { id: 'friendly', label: 'Friendly', instruction: 'Use a warm, approachable tone.' },
            { id: 'authoritative', label: 'Authoritative', instruction: 'Use a confident, expert tone.' },
            { id: 'poetic', label: 'Poetic', instruction: 'Use metaphors, rhythm, and evocative language.' },
            { id: 'concise', label: 'Concise', instruction: 'Use highly efficient, compact phrasing.' }
        ],
        LENGTH: [
            { id: 'short', label: 'SHORT', instruction: 'Maximum 2 short paragraphs.' },
            { id: 'medium', label: 'MEDIUM', instruction: 'Up to 6 paragraphs with examples.' },
            { id: 'long', label: 'LONG', instruction: 'Extensive, detailed long-form content.' }
        ],
        FADER_LEVELS: [
            "- Level 1: Basic Summary or Definition.",
            "- Level 2: Add Context, History, or Motivation.",
            "- Level 3: Add Structure, Examples, or Interactions.",
            "- Level 4: Add Advanced Analysis, Troubleshooting, or Exercises.",
            "- Level 5: Full Interactive App / Deep-Dive Artifact."
        ],
        RESTRICTIONS: [
            "Do not include filler text.",
            "Do not split the output into multiple messages.",
            "No disclaimers unless strictly necessary.",
            "Avoid repetition.",
            "Respect the selected format exactly."
        ]
    },
    COMPLEX: {
        TASK_TYPES: [
            { id: 'explain', label: 'DEMYSTIFY', instruction: 'Take the specific topic and break it down from first principles. Reveal the underlying logic clearly, making the complex intuitive.' },
            { id: 'analysis', label: 'DECONSTRUCT', instruction: 'Perform a deep-dive analysis. Identify root causes, systemic connections, variables, and potential edge cases within the context.' },
            { id: 'create', label: 'IDEATE & SYNTHESIZE', instruction: 'Generate novel, non-obvious content. Combine disparate concepts from the context to create something original and transformative.' },
            { id: 'teach', label: 'SCAFFOLDED MASTERY', instruction: 'Design a learning path. Introduce the concept, show a concrete example, explain the nuance, and provide a test/challenge for the user.' },
            { id: 'improve', label: 'REFACTOR & ELEVATE', instruction: 'Critique the input. Optimize for clarity, efficiency, and impact. Explain specifically what was improved and why.' },
            { id: 'compare', label: 'JUXTAPOSE & EVALUATE', instruction: 'Compare entities using rigorous criteria. Highlight trade-offs, synergies, and contextual suitability. Declare a winner based on the specific context.' },
            { id: 'build', label: 'ARCHITECT', instruction: 'Construct a complete artifact (plan, blueprint, codebase) from start to finish. Ensure all components logically fit together into a working whole.' }
        ],
        VOICES: [
            { id: 'neutral', label: 'Objective / Analytical', instruction: 'Maintain a bias-free, factual, and observably detached tone.' },
            { id: 'friendly', label: 'Warm / Collaborative', instruction: 'Use an inviting, encouraging, and psychologically safe tone.' },
            { id: 'authoritative', label: 'Commanding / Expert', instruction: 'Use decisive, unwavering language. Project absolute confidence.' },
            { id: 'poetic', label: 'Lyrical / Evocative', instruction: 'Use metaphor, rhythm, and sensory imagery to paint a picture with words.' },
            { id: 'concise', label: 'Minimalist / Direct', instruction: 'Maximize information density. Remove all fluff. Be surgical.' }
        ],
        LENGTH: [
            { id: 'short', label: 'ATOMIC', instruction: 'Provide the answer in a distilled format. Maximum impact, minimum word count (approx. 100 words).' },
            { id: 'medium', label: 'COMPREHENSIVE', instruction: 'Explore the topic with sufficient detail, examples, and nuance. Standard depth (approx. 400 words).' },
            { id: 'long', label: 'EXHAUSTIVE', instruction: 'Leave no stone unturned. Cover history, theory, application, and edge cases. Extensive length.' }
        ],
        FADER_LEVELS: [
            "- Level 1: Surface (Define the core concept simply).",
            "- Level 2: Context (Add historical background or 'Why it matters').",
            "- Level 3: Mechanics (Explain 'How it works' with examples).",
            "- Level 4: Nuance (Discuss optimization, edge cases, and trade-offs).",
            "- Level 5: Mastery (Full systemic integration and advanced synthesis). "
        ],
        RESTRICTIONS: [
            "Strictly follow the chosen FORMAT structure.",
            "Do not include conversational filler (e.g., 'Here is your...'). Start directly with the output.",
            "Ensure the tone aligns perfectly with the chosen MODE and VOICE.",
            "Integrate the User's CONTEXT and SPECIFIC TOPIC seamlessly.",
            "Output must be complete; do not cut off or ask to continue."
        ]
    }
};

/* =========================================
   2. GLOBAL STATE & PERSISTENCE
   ========================================= */
let lastGeneratedPrompt = ""; 
let currentData = ALGORITHMS.SIMPLEX; 
let nexusHistory = [];
const NEXUS_STORAGE_KEY = 'nexus_prompt_history';
const MDC_VOCAB_KEY = 'mdc_vocab_list';

/* =========================================
   3. INITIALIZATION
   ========================================= */
document.addEventListener('DOMContentLoaded', () => {
    populateSelect('modeSelect', COMMON_DATA.MODES);
    populateSelect('formatSelect', COMMON_DATA.FORMATS);
    updateDynamicDropdowns();
    loadHistory('contextInput', 'context-history');
    loadHistory('topicInput', 'topic-history');
    loadNexusHistory();
});

/* =========================================
   4. LOGIC: SAVE TO MDC VOCAB (EXTERNAL)
   ========================================= */
function sanitizeText(text) {
    if (!text) return "";
    text = text.replace(/['`‚Äò¬¥]/g, "‚Äô");
    text = text.replace(/[^a-zA-Z0-9\u00C0-\u017F\s‚Äô]/g, "");
    return text.trim();
}

// Helper para obtener TODAS las palabras guardadas actualmente en la App 1
function getVocabSet() {
    const raw = localStorage.getItem(MDC_VOCAB_KEY);
    if (!raw) return new Set();
    const items = JSON.parse(raw);
    const wordSet = new Set();

    // Recorremos carpetas y items sueltos
    items.forEach(i => {
        if (!i.isFolder && i.eng) wordSet.add(sanitizeText(i.eng).toLowerCase());
        else if (i.isFolder && i.items) {
            i.items.forEach(sub => {
                if(sub.eng) wordSet.add(sanitizeText(sub.eng).toLowerCase());
            });
        }
    });
    return wordSet;
}

function saveWordToMDC(word, element) {
    const cleanWord = sanitizeText(word);
    if(!cleanWord) return;

    let items = JSON.parse(localStorage.getItem(MDC_VOCAB_KEY) || '[]');
    
    // Check duplicados
    const checkEng = cleanWord.toLowerCase();
    const currentSet = getVocabSet();

    if (!currentSet.has(checkEng)) {
        // Guardar
        items.unshift({ 
            id: Date.now(), 
            isFolder: false, 
            eng: cleanWord, 
            esp: "", 
            isHighlighted: false 
        });
        localStorage.setItem(MDC_VOCAB_KEY, JSON.stringify(items));
        
        // Feedback Visual
        element.classList.add('saved');
    } else {
        // Ya existe (feedback temporal si no estaba marcado ya)
        element.style.color = 'orange';
        setTimeout(() => { 
            // Si estaba guardado (tiene clase saved), volver a rosa, si no, volver a normal
            if(element.classList.contains('saved')) element.style.color = ''; 
            else element.style.color = ''; 
        }, 500);
    }
}

/* =========================================
   5. LOGIC: NEXUS PERSISTENCE (INTERNAL)
   ========================================= */
function loadNexusHistory() {
    const stored = localStorage.getItem(NEXUS_STORAGE_KEY);
    if (stored) {
        nexusHistory = JSON.parse(stored);
        [...nexusHistory].reverse().forEach(data => renderAccordionDOM(data));
    }
}

function saveNexusState() {
    localStorage.setItem(NEXUS_STORAGE_KEY, JSON.stringify(nexusHistory));
}

function addToNexusHistory(data) {
    nexusHistory.unshift(data);
    saveNexusState();
}

function removeFromNexusHistory(id) {
    nexusHistory = nexusHistory.filter(item => item.id !== id);
    saveNexusState();
}

/* =========================================
   6. UI LOGIC & RENDERING (THE FIX IS HERE)
   ========================================= */

// Aqu√≠ est√° la soluci√≥n: Le pasamos el Set de palabras guardadas para comparar al renderizar
function formatInteractiveContent(text, existingVocabSet) {
    if (!text) return "";
    const safeText = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    
    // Dividimos y reconstruimos
    return safeText.split(/(\s+)/).map(token => {
        if (token.match(/^\s+$/)) return token; // Es espacio
        
        const cleanToken = sanitizeText(token).toLowerCase();
        // Verificamos si existe en la DB
        const isSaved = existingVocabSet.has(cleanToken);
        const className = isSaved ? "interactive-word saved" : "interactive-word";

        return `<span class="${className}" onclick="saveWordToMDC(this.innerText, this)">${token}</span>`;
    }).join('');
}

function renderAccordionDOM(data) {
    // 1. Obtener lista actual de palabras guardadas
    const currentVocab = getVocabSet();

    const container = document.getElementById('results-container');
    const item = document.createElement('div');
    item.className = 'accordion-item';
    item.id = `item-${data.id}`;
    
    // 2. Pasamos la lista a la funci√≥n de formateo
    const interactiveHTML = formatInteractiveContent(data.content, currentVocab);

    item.innerHTML = `
        <div class="accordion-header" onclick="toggleAccordion(${data.id})">
            <div class="header-content">
                <span class="meta-tag">${data.modeName}</span>
                <strong>${data.topic}</strong>
            </div>
            <div class="header-actions">
                <button class="btn-delete" onclick="deleteItem(event, ${data.id})">üóëÔ∏è</button>
                <span>‚ñº</span>
            </div>
        </div>
        <div class="accordion-content" id="content-${data.id}">
            <button class="copy-prompt-btn" onclick="copyTextToClipboard(this)">
                üìú Copy Original Prompt
            </button>
            <div style="display:none;" class="prompt-source">${data.prompt}</div>
            <hr style="border:0; border-top:1px solid #444; margin:10px 0;">
            <div style="white-space: pre-wrap;">${interactiveHTML}</div>
        </div>
    `;

    if(document.getElementById(`item-${data.id}`)) return;

    if (container.firstChild) {
        container.insertBefore(item, container.firstChild);
    } else {
        container.appendChild(item);
    }
}

// --- Resto de funciones UI ---
function toggleAlgorithmMode() {
    const isComplex = document.getElementById('modeSwitch').checked;
    if (isComplex) {
        currentData = ALGORITHMS.COMPLEX;
        document.getElementById('labelSimple').classList.remove('active');
        document.getElementById('labelComplex').classList.add('active');
    } else {
        currentData = ALGORITHMS.SIMPLEX;
        document.getElementById('labelSimple').classList.add('active');
        document.getElementById('labelComplex').classList.remove('active');
    }
    updateDynamicDropdowns();
}

function updateDynamicDropdowns() {
    populateSelect('taskSelect', currentData.TASK_TYPES);
    populateSelect('voiceSelect', currentData.VOICES);
    populateSelect('lengthSelect', currentData.LENGTH);
    const levelSel = document.getElementById('levelSelect');
    levelSel.innerHTML = '';
    currentData.FADER_LEVELS.forEach((level) => {
        let opt = document.createElement('option');
        opt.value = level;
        opt.textContent = level.split(':')[0];
        levelSel.appendChild(opt);
    });
}

function populateSelect(id, dataArray) {
    const select = document.getElementById(id);
    select.innerHTML = '';
    dataArray.forEach(item => {
        let opt = document.createElement('option');
        opt.value = item.id;
        opt.textContent = item.label;
        select.appendChild(opt);
    });
}

function loadHistory(inputId, listId) {
    const history = JSON.parse(localStorage.getItem(inputId + '_mem')) || [];
    const dataList = document.getElementById(listId);
    if(dataList) {
        dataList.innerHTML = '';
        history.forEach(item => {
            let option = document.createElement('option');
            option.value = item;
            dataList.appendChild(option);
        });
    }
}

function saveToHistory(inputId) {
    const input = document.getElementById(inputId);
    const value = input.value.trim();
    if (!value) return;
    let history = JSON.parse(localStorage.getItem(inputId + '_mem')) || [];
    history = history.filter(item => item !== value);
    history.unshift(value);
    if (history.length > 5) history.pop();
    localStorage.setItem(inputId + '_mem', JSON.stringify(history));
    loadHistory(inputId, input.getAttribute('list'));
}

function generatePrompt() {
    const context = document.getElementById('contextInput').value;
    const topic = document.getElementById('topicInput').value;
    const mode = COMMON_DATA.MODES.find(m => m.id === document.getElementById('modeSelect').value);
    const format = COMMON_DATA.FORMATS.find(f => f.id === document.getElementById('formatSelect').value);
    const task = currentData.TASK_TYPES.find(t => t.id === document.getElementById('taskSelect').value);
    const voice = currentData.VOICES.find(v => v.id === document.getElementById('voiceSelect').value);
    const len = currentData.LENGTH.find(l => l.id === document.getElementById('lengthSelect').value);
    const level = document.getElementById('levelSelect').value;

    const prompt = `
### ROLE & STYLE
${mode.role} ${mode.style}
Goal: ${mode.goal}

### TASK
Context: ${context}
Topic: ${topic}
Type: ${task.label} - ${task.instruction}

### FORMAT & OUTPUT
Format: ${format.label}
Instruction: ${format.instruction}
Tone: ${voice.instruction}
Length: ${len.instruction}
Depth: ${level}

### RESTRICTIONS
${currentData.RESTRICTIONS.join('\n')}
    `.trim();

    const outputDiv = document.getElementById('prompt-output');
    outputDiv.style.display = 'block';
    outputDiv.textContent = prompt;
    navigator.clipboard.writeText(prompt);
    lastGeneratedPrompt = prompt;
    saveToHistory('contextInput');
    saveToHistory('topicInput');
}

async function handlePasteResponse() {
    try {
        const text = await navigator.clipboard.readText();
        if(!text) return alert("Clipboard is empty.");
        
        const data = {
            id: Date.now(),
            modeName: document.getElementById('modeSelect').options[document.getElementById('modeSelect').selectedIndex].text,
            topic: document.getElementById('topicInput').value || "Untitled Result",
            prompt: lastGeneratedPrompt,
            content: text
        };

        addToNexusHistory(data);
        renderAccordionDOM(data);
        toggleGenerator(false);
    } catch (err) {
        alert("Permission denied or error reading clipboard.");
    }
}

function toggleGenerator(show) {
    const gen = document.getElementById('generator-container');
    const btnShow = document.getElementById('btn-show-gen');
    if (show) {
        gen.classList.remove('hidden');
        btnShow.style.display = 'none';
    } else {
        gen.classList.add('hidden');
        btnShow.style.display = 'block';
    }
}

function deleteItem(event, id) {
    event.stopPropagation();
    if(confirm("Are you sure you want to delete this result?")) {
        const el = document.getElementById(`item-${id}`);
        if(el) el.remove();
        removeFromNexusHistory(id);
    }
}

function toggleAccordion(id) {
    const content = document.getElementById(`content-${id}`);
    const isVisible = content.classList.contains('active');
    document.querySelectorAll('.accordion-content').forEach(c => c.classList.remove('active'));
    if (!isVisible) {
        content.classList.add('active');
    }
}

function copyTextToClipboard(btnElement) {
    const promptText = btnElement.nextElementSibling.textContent;
    navigator.clipboard.writeText(promptText).then(() => {
        const originalText = btnElement.innerText;
        btnElement.innerText = "Copied!";
        setTimeout(() => btnElement.innerText = originalText, 1500);
    });
}
</script>

</body>
</html>
