<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Prompt Generator (Hybrid Logic)</title>
    <link href="https://fonts.googleapis.com/css2?family=Segoe+UI:wght@400;600;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        :root {
            --bg: #121212;
            --surface: #1e1e1e;
            --primary: #bb86fc;
            --text: #e0e0e0;
            --border: #333;
            --accent-active: #2196F3;
            --danger: #cf6679;
            
            /* === COLORES DE VOCABULARIO === */
            --saved-word: #ec4899;  /* Rosa (Palabra suelta) */
            --phrase-word: #f59e0b; /* √Åmbar (Frase completa) */
            
            --daw-bg: #222;
            --daw-screen-bg: #050505;
            --daw-text: #00ffcc;
        }

        body {
            font-family: 'Segoe UI', monospace, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0; padding: 0;
            display: flex; flex-direction: column; align-items: center;
            overflow-x: hidden; width: 100%; padding-bottom: 80px; 
            
            /* GLOBAL USER SELECT BLOCK */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* --- BLOQUEO DE SELECCI√ìN NATIVA --- */
        .interactive-word, .accordion-header, h2, .mode-label, .vocab-badge, .daw-panel {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            cursor: pointer;
        }

        input, textarea, .prompt-source, #prompt-output {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
            cursor: text;
        }

        /* === LAYOUT & CONTAINERS === */
        #generator-container {
            width: 100%; max-width: none; background: var(--surface);
            padding: 20px; margin: 0; border-bottom: 1px solid var(--border);
            transition: all 0.3s ease;
        }
        .hidden { display: none !important; }
        h2 { margin-top: 0; color: var(--primary); text-align: center; }

        .switch-wrapper { display: flex; align-items: center; justify-content: center; margin-bottom: 20px; gap: 15px; font-weight: bold; font-size: 0.9em; }
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent-active); }
        input:checked + .slider:before { transform: translateX(26px); }
        .mode-label { opacity: 0.5; transition: 0.3s; color: #aaa; }
        .mode-label.active { opacity: 1; color: white; font-weight: bold; }

        /* === PANEL DE VOCABULARIO === */
        #vocab-controls {
            background: #181818;
            border: 1px solid #333;
            border-left: 4px solid #444; 
            border-radius: 6px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        #vocab-controls.active-panel {
            border-left-color: var(--saved-word);
            background: #1f1a1d; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .vocab-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 15px; cursor: pointer;
        }

        .vocab-toggle-wrapper {
            display: flex; align-items: center; gap: 12px;
            font-weight: 600; color: #ccc; font-size: 1rem; transition: color 0.3s;
        }

        #vocab-controls.active-panel .vocab-toggle-wrapper {
            color: white; text-shadow: 0 0 8px rgba(236, 72, 153, 0.4);
        }

        .custom-checkbox {
            appearance: none; -webkit-appearance: none;
            width: 40px; height: 22px; background: #333; border-radius: 20px;
            position: relative; cursor: pointer; transition: background 0.3s; flex-shrink: 0;
        }
        .custom-checkbox::after {
            content: ''; position: absolute; top: 2px; left: 2px; width: 18px; height: 18px;
            background: #888; border-radius: 50%; transition: transform 0.3s, background 0.3s;
        }
        .custom-checkbox:checked { background: rgba(236, 72, 153, 0.2); border: 1px solid var(--saved-word); }
        .custom-checkbox:checked::after {
            transform: translateX(18px); background: var(--saved-word); box-shadow: 0 0 8px var(--saved-word);
        }

        .vocab-badge {
            background: #252525; color: #777; padding: 4px 8px; border-radius: 4px;
            font-size: 0.75rem; font-family: 'Roboto Mono', monospace; letter-spacing: 0.5px;
            border: 1px solid #333; white-space: nowrap; transition: all 0.3s;
        }
        #vocab-controls.active-panel .vocab-badge {
            border-color: var(--saved-word); color: var(--saved-word); background: rgba(236, 72, 153, 0.05);
        }

        .vocab-settings {
            padding: 15px; background: #141414; border-top: 1px solid #333;
            display: none; animation: slideDown 0.3s ease-out;
        }
        @keyframes slideDown { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        /* === GENERAL INPUTS === */
        .grid-container { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px; }
        @media (max-width: 600px) { .grid-container { grid-template-columns: 1fr; } } 
        
        label { display: block; margin-bottom: 5px; font-size: 0.9em; color: #aaa; }
        input, select, textarea { width: 100%; background: #2d2d2d; border: 1px solid var(--border); color: white; padding: 10px; border-radius: 4px; outline: none; }
        input:disabled { opacity: 0.5; cursor: not-allowed; background: #222; border-color: #333; color: #777; }
        
        #modeSelect { transition: border-color 0.3s ease; border: 1px solid var(--border); }

        .btn-group { display: flex; gap: 10px; margin-top: 20px; }
        button { flex: 1; padding: 12px; cursor: pointer; font-weight: bold; border: none; border-radius: 4px; transition: background 0.2s; }
        #btn-generate { background-color: var(--primary); color: #000; }
        #btn-paste { background-color: #03dac6; color: #000; }
        #btn-show-gen { background-color: #333; color: #fff; margin: 0; padding: 15px; display: none; width: 100%; border-radius: 0; }
        #prompt-output { margin-top: 20px; background: #000; padding: 15px; border: 1px solid var(--primary); font-family: monospace; white-space: pre-wrap; display: none; }

        /* === SEARCH & RESULTS === */
        #search-container { width: 100%; background: var(--surface); padding: 10px 20px; border-bottom: 1px solid var(--border); margin-bottom: 10px; }
        #searchBar { width: 100%; background: #121212; border: 1px solid #333; color: white; padding: 12px; border-radius: 4px; font-size: 16px; }
        #results-container { width: 100%; padding: 0 20px 20px 20px; }
        .accordion-item { background: var(--surface); border: 1px solid var(--border); margin-bottom: 10px; border-radius: 4px; overflow: hidden; }
        .accordion-header { padding: 15px; background: #252525; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .header-content { display: flex; flex-direction: column; gap: 4px; }
        .meta-tag { background: #333; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; display: inline-block; width: fit-content; }
        .btn-delete { background: transparent; color: #666; border: 1px solid #444; padding: 5px 12px; border-radius: 4px; font-size: 1.2em; }
        .accordion-content { padding: 15px; display: none; border-top: 1px solid var(--border); font-size: 0.95em; line-height: 1.6; }
        .accordion-content.active { display: block; }
        
        /* BOTONES DE ACCI√ìN */
        .action-row { display: flex; gap: 10px; margin-bottom: 15px; }
        .copy-prompt-btn, .save-phrase-btn { border: none; padding: 8px 12px; font-size: 0.85em; border-radius: 4px; cursor: pointer; width: 100%; font-weight: bold; }
        .copy-prompt-btn { background: var(--primary); color: black; }
        
        /* Bot√≥n Guardar Frase (Inactivo por defecto) */
        .save-phrase-btn { background: #374151; color: white; border: 1px solid #4b5563; opacity: 0.5; pointer-events: none; transition: all 0.2s; }
        .save-phrase-btn.ready { opacity: 1; pointer-events: all; background: var(--phrase-word); border-color: white; box-shadow: 0 0 10px rgba(245, 158, 11, 0.4); }

        /* === INTERACTIVE WORDS (L√ìGICA H√çBRIDA) === */
        .interactive-word { 
            cursor: pointer; 
            border-bottom: 2px solid transparent; 
            padding: 0 1px; 
            transition: all 0.2s; 
            border-radius: 2px;
            display: inline-block;
        }
        .interactive-word:hover { background: rgba(255, 255, 255, 0.1); }
        
        /* 1. PALABRA GUARDADA (ROSA) */
        .interactive-word.saved { 
            color: var(--saved-word); 
            font-weight: bold; 
            border-bottom: 2px solid var(--saved-word);
            text-shadow: none;
        }

        /* 2. FRASE GUARDADA (√ÅMBAR) */
        .interactive-word.phrase-saved {
            background-color: var(--phrase-word) !important;
            color: white !important;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            margin: 0 1px;
            font-weight: normal;
            border-bottom: none; /* Por defecto sin borde */
            text-shadow: none !important;
        }

        /* 3. ESTADO H√çBRIDO: ES FRASE (AMBAR) Y PALABRA (ROSA) A LA VEZ */
        .interactive-word.saved.phrase-saved {
            /* Mantiene fondo ambar y texto blanco de .phrase-saved */
            /* Pero a√±ade el indicador visual de palabra guardada */
            border-bottom: 3px solid var(--saved-word) !important; /* Borde rosa m√°s grueso */
        }

        /* 4. SELECCI√ìN ACTIVA (LONG PRESS) */
        .interactive-word.phrase-selecting {
            background-color: rgba(245, 158, 11, 0.5) !important; /* √Åmbar transl√∫cido */
            color: white !important;
            border: 1px dashed var(--phrase-word);
            border-radius: 4px;
        }

        /* === DAW AUDIO PLAYER === */
        .daw-panel {
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            border: 1px solid #444; border-radius: 6px; padding: 12px; margin: 10px 0 20px 0;
            display: flex; flex-direction: column; gap: 12px;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.1), 0 4px 10px rgba(0,0,0,0.5);
            font-family: 'Roboto Mono', monospace;
        }
        .daw-top-deck { display: flex; gap: 10px; width: 100%; height: 44px; }
        .daw-btn-play {
            width: 44px; height: 44px; background: #111; border: 2px solid #555; border-radius: 4px; color: #888;
            cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 18px; flex-shrink: 0;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }
        .daw-btn-play:active { transform: translateY(2px); box-shadow: inset 0 4px 8px rgba(0,0,0,0.8); }
        .daw-btn-play.playing { color: #0f0; border-color: #0f0; text-shadow: 0 0 8px #0f0; box-shadow: inset 0 0 15px rgba(0,255,0,0.2); background: #001100; }
        .daw-screen {
            flex: 1; background: var(--daw-screen-bg); border: 1px solid #333; border-radius: 2px;
            display: flex; align-items: center; padding: 0 12px; color: #06b6d4; font-size: 0.85em;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8); position: relative; overflow: hidden; white-space: nowrap;
        }
        .daw-screen.active { color: #0f0; }
        .daw-control-deck { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center; }
        .daw-knob-group { display: flex; flex-direction: column; gap: 4px; }
        .daw-label { font-size: 0.65em; color: #777; text-transform: uppercase; letter-spacing: 1px; font-weight: bold; }
        .daw-slider { -webkit-appearance: none; width: 100%; height: 24px; background: transparent; margin: 0; }
        .daw-slider::-webkit-slider-runnable-track { width: 100%; height: 6px; background: #000; border: 1px solid #333; border-radius: 3px; }
        .daw-slider::-webkit-slider-thumb { -webkit-appearance: none; height: 18px; width: 10px; background: #888; border: 1px solid #000; border-radius: 2px; margin-top: -7px; box-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .daw-select { background: #111; color: #ccc; border: 1px solid #444; font-family: 'Roboto Mono', monospace; font-size: 0.8em; padding: 8px; width: 100%; border-radius: 2px; height: 32px; }
        @media (min-width: 768px) {
            .daw-panel { flex-direction: row; height: 60px; }
            .daw-top-deck { width: auto; flex: 1; }
            .daw-control-deck { display: flex; gap: 20px; width: auto; }
            .daw-slider { width: 100px; }
            .daw-select { width: 140px; }
        }

        /* === UNIFIED PILL (Bottom Center) === */
        #unified-pill {
            position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%) translateY(150%);
            background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 50px;
            padding: 8px 20px; box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            display: flex; align-items: center; gap: 15px; 
            z-index: 5000; transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 95%; white-space: nowrap;
        }
        #unified-pill.visible { transform: translateX(-50%) translateY(0); }

        .pill-section { display: flex; align-items: center; gap: 8px; }
        .pill-icon { font-size: 1.1em; }
        
        /* Stats Section */
        #pill-stats-text {
            font-family: 'Roboto Mono', monospace; font-weight: 800; font-size: 1em; 
            color: #e5e7eb; letter-spacing: 1px;
        }
        .stats-active { color: var(--saved-word) !important; }

        /* Divider */
        .pill-divider { width: 1px; height: 16px; background: rgba(255,255,255,0.2); }

        /* Translate Section */
        #pill-trans { display: none; } /* Hidden by default */
        #pill-trans.active { display: flex; }
        .trans-origin { color: #aaa; font-style: italic; font-size: 0.9em; }
        .trans-arrow { color: #666; font-size: 0.8em; margin: 0 4px; }
        .trans-result { color: #fff; font-weight: 700; font-size: 0.95em; }

    </style>
</head>
<body>

    <div id="unified-pill">
        <div class="pill-section">
            <span class="pill-icon">üìä</span>
            <span id="pill-stats-text">- | 0</span>
        </div>
        
        <div id="pill-divider" class="pill-divider" style="display:none;"></div>

        <div id="pill-trans" class="pill-section">
            <span id="trans-origin" class="trans-origin">...</span>
            <span class="trans-arrow">‚Üí</span>
            <span id="trans-result" class="trans-result">...</span>
        </div>
    </div>

    <button id="btn-show-gen" onclick="toggleGenerator(true)">‚ûï New Generation</button>

    <div id="generator-container">
        <h2>Nexus Prompt Engineer</h2>
        
        <div class="switch-wrapper">
            <span id="labelSimple" class="mode-label active">SIMPLE</span>
            <label class="switch">
                <input type="checkbox" id="modeSwitch" onchange="toggleAlgorithmMode()">
                <span class="slider"></span>
            </label>
            <span id="labelComplex" class="mode-label">COMPLEX</span>
        </div>

        <div id="vocab-controls">
            <div class="vocab-header" onclick="document.getElementById('useVocabCheckbox').click()">
                <div class="vocab-toggle-wrapper">
                    <input type="checkbox" id="useVocabCheckbox" class="custom-checkbox" onclick="event.stopPropagation()" onchange="toggleVocabMode()">
                    <span>Inject MDC Vocab</span>
                </div>
                <span id="vocab-count-badge" class="vocab-badge">Checking DB...</span>
            </div>

            <div id="vocab-settings" class="vocab-settings">
                <div class="grid-container" style="margin-bottom:0;">
                    <div>
                        <label>Source</label>
                        <select id="vocabSource">
                            <option value="all">üåê All Words</option>
                            <option value="highlighted">‚≠ê Highlighted</option>
                            <option value="recent">Hz Recent (10)</option>
                            <optgroup id="folder-group" label="üìÇ Folders"></optgroup>
                        </select>
                    </div>
                    <div>
                        <label>Amount (Words)</label>
                        <input type="number" id="vocabAmount" value="5" min="1" max="50">
                    </div>
                </div>
                <div style="font-size: 0.8em; color: #666; margin-top:10px; font-style:italic; border-top: 1px solid #222; padding-top: 5px;">
                    ‚ÑπÔ∏è "Learning Mode" active: Topic is locked. Task dictates the Persona.
                </div>
            </div>
        </div>
        <div class="grid-container">
            <div>
                <label>Context</label>
                <input type="text" id="contextInput" list="context-history" placeholder="Ex: React, Finance...">
                <datalist id="context-history"></datalist>
            </div>
            <div>
                <label>Specific Topic</label>
                <input type="text" id="topicInput" list="topic-history" placeholder="Ex: Hooks, ROI...">
                <datalist id="topic-history"></datalist>
            </div>

            <div><label>Mode (Persona)</label><select id="modeSelect"></select></div>
            <div><label>Format</label><select id="formatSelect"></select></div>
            
            <div><label id="taskLabel">Task Type</label><select id="taskSelect" onchange="syncModeWithTask()"></select></div>
            
            <div><label>Voice/Tone</label><select id="voiceSelect"></select></div>
            <div><label>Length</label><select id="lengthSelect"></select></div>
            <div><label>Depth Level</label><select id="levelSelect"></select></div>
        </div>

        <div class="btn-group">
            <button id="btn-generate" onclick="generatePrompt()">‚ö° Generate Prompt</button>
            <button id="btn-paste" onclick="handlePasteResponse()">üìã Paste Response & Hide</button>
        </div>

        <div id="prompt-output"></div>
    </div>

    <div id="search-container">
        <input type="text" id="searchBar" placeholder="üîç Search saved prompts..." onkeyup="filterResults()">
    </div>

    <div id="results-container"></div>

<script>
/* 1. CONFIG DATA */
const COMMON_DATA = {
    MODES: [
        { id: 'tech', label: 'TECHNICAL', role: 'Act as a Senior Engineer.', style: 'Cyberpunk/Terminal style.', goal: 'Technical accuracy and implementation detail.' },
        { id: 'art', label: 'ART', role: 'Act as a Creative Director.', style: 'Minimalist Gallery / Editorial style.', goal: 'Aesthetic refinement and originality.' },
        { id: 'school', label: 'SCHOOL', role: 'Act as a Professor.', style: 'Clean Textbook / Academic style.', goal: 'Structured education and conceptual clarity.' },
        { id: 'story', label: 'STORYTELLING', role: 'Act as a Master Novelist.', style: 'Cinematic, immersive narrative tone.', goal: 'Engaging storytelling and world-building.' },
        { id: 'marketing', label: 'MARKETING', role: 'Act as a Senior Copywriter.', style: 'Persuasive, high-conversion writing.', goal: 'Brand voice alignment & audience engagement.' },
        { id: 'business', label: 'BUSINESS', role: 'Act as a Strategy Consultant.', style: 'Executive brief style.', goal: 'Clarity, precision, and actionable insights.' },
        { id: 'research', label: 'RESEARCH', role: 'Act as a Research Scientist.', style: 'Peer-reviewed academic tone.', goal: 'Evidence-based rigor with citations when relevant.' },
        { id: 'casual', label: 'CASUAL', role: 'Act as a friendly assistant.', style: 'Conversational, natural tone.', goal: 'Clarity, simplicity, and a human-sounding delivery.' }
    ],
    FORMATS: [
        { id: 'text', label: 'TEXT GUIDE', instruction: 'Return Markdown text with clear headings and structure.' },
        { id: 'html', label: 'HTML APP', instruction: 'Return a single HTML5 file with inline CSS/JS. No external files. Use overflow-y:auto.' },
        { id: 'code', label: 'CODE SNIPPET', instruction: 'Return raw code only with comments.' },
        { id: 'essay', label: 'ESSAY', instruction: 'Return a polished formal essay.' },
        { id: 'dialogue', label: 'DIALOGUE', instruction: 'Return a scripted scene or conversation.' },
        { id: 'template', label: 'TEMPLATE', instruction: 'Return a reusable structured template with fillable fields.' },
        { id: 'checklist', label: 'CHECKLIST', instruction: 'Return a concise actionable checklist or SOP.' }
    ]
};

const VOCAB_TASKS = [
    { id: 'v_story', label: 'üìñ VOCAB: Creative Story', instruction: 'Write a short, engaging story incorporating the target vocabulary naturally.', linkedMode: 'story' },
    { id: 'v_quiz', label: '‚ùì VOCAB: Quiz Generator', instruction: 'Create a multiple-choice quiz (with answer key) testing the definition and usage of these words.', linkedMode: 'school' },
    { id: 'v_dialogue', label: 'üí¨ VOCAB: Roleplay Dialogue', instruction: 'Write a script for a realistic conversation between two people using these words.', linkedMode: 'casual' },
    { id: 'v_sentences', label: '‚úçÔ∏è VOCAB: Sentence Drill', instruction: 'Generate 3 distinct sentences (Context A, B, and C) for each target word.', linkedMode: 'school' },
    { id: 'v_explain', label: 'üß† VOCAB: Deep Explanation', instruction: 'Explain the etymology, nuance, and common collocations for each word.', linkedMode: 'research' }
];

const ALGORITHMS = {
    SIMPLEX: {
        TASK_TYPES: [
            { id: 'explain', label: 'EXPLANATION', instruction: 'Explain the topic clearly and step-by-step.' },
            { id: 'analysis', label: 'ANALYSIS', instruction: 'Break the topic down into components with pros, cons, variables.' },
            { id: 'create', label: 'CREATIVE GENERATION', instruction: 'Generate original content in the selected style.' },
            { id: 'teach', label: 'TEACHING', instruction: 'Introduce, teach, give examples, and add a practice checkpoint.' },
            { id: 'improve', label: 'IMPROVEMENT', instruction: 'Rewrite and enhance the user‚Äôs content with better clarity and style.' },
            { id: 'compare', label: 'COMPARISON', instruction: 'Compare items using structure, criteria, and reasoning.' },
            { id: 'build', label: 'CONSTRUCTION', instruction: 'Produce a structured artifact: plan, blueprint, script, architecture, or framework.' }
        ],
        VOICES: [ { id: 'neutral', label: 'Neutral', instruction: 'Use a balanced, neutral tone.' }, { id: 'friendly', label: 'Friendly', instruction: 'Use a warm, approachable tone.' }, { id: 'authoritative', label: 'Authoritative', instruction: 'Use a confident, expert tone.' }, { id: 'poetic', label: 'Poetic', instruction: 'Use metaphors, rhythm, and evocative language.' }, { id: 'concise', label: 'Concise', instruction: 'Use highly efficient, compact phrasing.' } ],
        LENGTH: [ { id: 'short', label: 'SHORT', instruction: 'Maximum 2 short paragraphs.' }, { id: 'medium', label: 'MEDIUM', instruction: 'Up to 6 paragraphs with examples.' }, { id: 'long', label: 'LONG', instruction: 'Extensive, detailed long-form content.' } ],
        FADER_LEVELS: ["- Level 1: Basic Summary.", "- Level 2: Add Context.", "- Level 3: Add Structure.", "- Level 4: Add Advanced Analysis.", "- Level 5: Full Deep-Dive."],
        RESTRICTIONS: ["Do not include filler text.", "No disclaimers.", "Respect format."]
    },
    COMPLEX: {
        TASK_TYPES: [
            { id: 'explain', label: 'DEMYSTIFY', instruction: 'Break down from first principles.' },
            { id: 'analysis', label: 'DECONSTRUCT', instruction: 'Deep-dive analysis with root causes.' },
            { id: 'create', label: 'IDEATE & SYNTHESIZE', instruction: 'Generate novel, non-obvious content.' },
            { id: 'teach', label: 'SCAFFOLDED MASTERY', instruction: 'Design a learning path with tests.' },
            { id: 'improve', label: 'REFACTOR & ELEVATE', instruction: 'Optimize for clarity and impact.' },
            { id: 'compare', label: 'JUXTAPOSE & EVALUATE', instruction: 'Rigorous comparison with trade-offs.' },
            { id: 'build', label: 'ARCHITECT', instruction: 'Construct a complete logical artifact.' }
        ],
        VOICES: [ { id: 'neutral', label: 'Objective', instruction: 'Bias-free, factual.' }, { id: 'friendly', label: 'Collaborative', instruction: 'Inviting and safe.' }, { id: 'authoritative', label: 'Expert', instruction: 'Decisive and confident.' }, { id: 'poetic', label: 'Evocative', instruction: 'Metaphorical and rhythmic.' }, { id: 'concise', label: 'Surgical', instruction: 'Maximum density, no fluff.' } ],
        LENGTH: [ { id: 'short', label: 'ATOMIC', instruction: 'Distilled impact.' }, { id: 'medium', label: 'COMPREHENSIVE', instruction: 'Sufficient detail.' }, { id: 'long', label: 'EXHAUSTIVE', instruction: 'No stone unturned.' } ],
        FADER_LEVELS: ["- Level 1: Surface.", "- Level 2: Context.", "- Level 3: Mechanics.", "- Level 4: Nuance.", "- Level 5: Mastery."],
        RESTRICTIONS: ["Strict format.", "No filler.", "Align tone.", "Integrate context.", "Complete output."]
    }
};

/* 2. GLOBAL STATE */
let lastGeneratedPrompt = ""; 
let currentData = ALGORITHMS.SIMPLEX; 
let nexusHistory = [];
const NEXUS_STORAGE_KEY = 'nexus_prompt_history';
const MDC_VOCAB_KEY = 'mdc_vocab_list';
const PREF_AUDIO_VOICE = 'nexus_audio_voice';
const PREF_AUDIO_SPEED = 'nexus_audio_speed';
let availableVoices = [];

// PILL STATE & WATCHER
let currentStatsContext = null;
let currentWordStats = { occurrences: "-", uniqueTotal: 0 };
let lastStorageString = "";

// VARS PARA LONG PRESS
let pressTimer;
let isLongPressHandled = false;

/* 3. INITIALIZATION */
document.addEventListener('DOMContentLoaded', () => {
    populateSelect('modeSelect', COMMON_DATA.MODES);
    populateSelect('formatSelect', COMMON_DATA.FORMATS);
    updateDynamicDropdowns();
    loadHistory('contextInput', 'context-history');
    loadHistory('topicInput', 'topic-history');
    loadNexusHistory();
    loadVocabFolders();
    startStorageWatcher(); 
    
    if(window.speechSynthesis) {
        window.speechSynthesis.onvoiceschanged = loadVoices;
        loadVoices();
    }
});

/* === REAL-TIME SYNC ENGINE (HYBRID LOGIC) === */
function startStorageWatcher() {
    lastStorageString = localStorage.getItem(MDC_VOCAB_KEY) || "";
    
    setInterval(() => {
        const currentString = localStorage.getItem(MDC_VOCAB_KEY) || "";
        if (currentString !== lastStorageString) {
            lastStorageString = currentString;
            loadVocabFolders(); 
            refreshActiveView(); 
        }
    }, 500);
}

function sanitizeText(text) {
    if (!text) return "";
    text = text.replace(/['`‚Äò¬¥]/g, "‚Äô");
    text = text.replace(/[^a-zA-Z0-9\u00C0-\u017F\s‚Äô]/g, ""); 
    return text.trim(); 
}

function refreshActiveView() {
    // 1. Detectar d√≥nde estamos
    const activeContent = document.querySelector('.accordion-content.active .interactive-content');
    if (!activeContent) return;

    // 2. Obtener datos de LocalStorage
    const rawData = JSON.parse(localStorage.getItem(MDC_VOCAB_KEY) || '[]');
    const savedWordsSet = new Set();
    const savedPhrases = [];

    // 3. Aplanar la base de datos (Extraer palabras y frases)
    const extract = (obj) => {
        const text = sanitizeText(obj.eng).toLowerCase();
        if(text.includes(" ")) {
            savedPhrases.push(text); // Es frase
        } else {
            savedWordsSet.add(text); // Es palabra
        }
    };

    rawData.forEach(item => {
        if(item.isFolder && item.items) item.items.forEach(sub => extract(sub));
        else if(!item.isFolder && item.eng) extract(item);
    });

    // Ordenar frases por longitud
    savedPhrases.sort((a, b) => b.length - a.length);

    // 4. Limpieza inicial del DOM
    const allWords = Array.from(activeContent.querySelectorAll('.interactive-word'));
    allWords.forEach(el => {
        // No tocamos lo que el usuario est√° seleccionando manualmente ahora mismo
        if (!el.classList.contains('phrase-selecting')) {
            el.classList.remove('saved', 'phrase-saved');
            delete el.dataset.phraseParent;
        }
    });

    // 5. PASADA 1: Pintar Palabras Sueltas (ROSA)
    allWords.forEach(el => {
        const clean = sanitizeText(el.innerText).toLowerCase();
        if (savedWordsSet.has(clean) && !el.classList.contains('phrase-selecting')) {
            el.classList.add('saved');
        }
    });

    // 6. PASADA 2: Pintar Frases (√ÅMBAR) - PERO SIN BORRAR EL ROSA
    // Creamos un array de texto limpio para comparar
    const lineTextArr = allWords.map(el => sanitizeText(el.innerText).toLowerCase());

    savedPhrases.forEach(phrase => {
        const phraseArr = phrase.split(" ");
        const phraseLen = phraseArr.length;

        // Recorremos el texto buscando coincidencias de la frase
        for (let i = 0; i <= lineTextArr.length - phraseLen; i++) {
            let match = true;
            for (let j = 0; j < phraseLen; j++) {
                if (lineTextArr[i + j] !== phraseArr[j]) { match = false; break; }
            }

            // Si hay coincidencia exacta
            if (match) {
                for (let k = 0; k < phraseLen; k++) {
                    const targetEl = allWords[i + k];
                    
                    // Aplicamos estilo √ÅMBAR (Inclusivo, no destructivo)
                    if (!targetEl.classList.contains('phrase-selecting')) {
                        // NOTA: NO borramos 'saved'. Dejamos que coexistan.
                        targetEl.classList.add('phrase-saved');
                        targetEl.dataset.phraseParent = phrase; 
                    }
                }
            }
        }
    });

    // 7. Actualizar estad√≠sticas de la p√≠ldora flotante
    currentStatsContext = activeContent;
    updateUnifiedPill(null);
}

/* === LONG PRESS LOGIC === */
function startPress(el) {
    isLongPressHandled = false;
    pressTimer = setTimeout(() => {
        handleLongPress(el);
        isLongPressHandled = true;
    }, 500); // 0.5s para activar selecci√≥n de frase
}

function endPress(el, e) {
    clearTimeout(pressTimer);
    if(e.type === 'touchend' && isLongPressHandled) {
        e.preventDefault(); 
    }
}

function handleShortClick(el) {
    if (isLongPressHandled) return; 

    // AQUI ESTA LA MAGIA: Permitimos guardar palabra individual INCLUSO si es parte de una frase.
    // Simplemente llamamos a la funci√≥n de guardar.
    // Si queremos ver la traducci√≥n de la frase completa, solo si tiene phraseParent
    
    // Prioridad: Si es parte de una frase PERO no est√° guardada como palabra individual,
    // al hacer click corto la guardamos como palabra (Rosa).
    
    saveWordToMDC(el.innerText, el); 
}

function handleLongPress(el) {
    if (navigator.vibrate) navigator.vibrate(50);
    el.classList.toggle('phrase-selecting');
    checkSelectionState(el);
}

function checkSelectionState(element) {
    const contentDiv = element.closest('.accordion-content');
    const selected = contentDiv.querySelectorAll('.phrase-selecting');
    const saveBtn = contentDiv.querySelector('.save-phrase-btn');
    
    if(selected.length > 0) {
        saveBtn.classList.add('ready');
        saveBtn.innerHTML = `üíæ Save Phrase (${selected.length})`;
    } else {
        saveBtn.classList.remove('ready');
        saveBtn.innerHTML = `üíæ Save Phrase`;
    }
}

function savePhraseSelection(btn) {
    const contentDiv = btn.closest('.accordion-content');
    const selected = Array.from(contentDiv.querySelectorAll('.phrase-selecting'));
    
    if (selected.length === 0) return;

    // Ordenar por √≠ndice para que la frase tenga sentido
    selected.sort((a,b) => parseInt(a.dataset.idx) - parseInt(b.dataset.idx));
    
    const phraseText = selected.map(el => sanitizeText(el.innerText)).join(" ");
    
    // Guardar forzosamente (esp vacio)
    forceSavePhrase(phraseText, contentDiv);

    // Limpiar UI
    selected.forEach(el => el.classList.remove('phrase-selecting'));
    btn.classList.remove('ready');
    btn.innerHTML = `üíæ Save Phrase`;
    
    refreshActiveView();
}

function forceSavePhrase(cleanPhrase, elementContext) {
    if (!cleanPhrase) return;
    let items = JSON.parse(localStorage.getItem(MDC_VOCAB_KEY) || '[]');
    const checkEng = cleanPhrase.toLowerCase();

    // Chequeo simple de duplicados en memoria
    let exists = false;
    items.forEach(i => {
        if (!i.isFolder && i.eng && sanitizeText(i.eng).toLowerCase() === checkEng) exists = true;
        if (i.isFolder && i.items) {
            i.items.forEach(sub => { if (sub.eng && sanitizeText(sub.eng).toLowerCase() === checkEng) exists = true; });
        }
    });

    if (exists) { alert("Phrase already saved."); return; }

    const accordionItem = elementContext.closest('.accordion-item');
    const folderName = accordionItem ? accordionItem.querySelector('.header-content strong').innerText.trim() : "AI Generator";
    
    // IMPORTANTE: esp: "" (Vacio), tal como solicitaste
    const newItem = { 
        id: Date.now(), 
        isFolder: false, 
        eng: cleanPhrase, 
        esp: "", 
        isHighlighted: false, 
        dateAdded: Date.now() 
    };
    
    let targetFolder = items.find(i => i.isFolder && i.name.toLowerCase() === folderName.toLowerCase());

    if (targetFolder) {
        targetFolder.items.unshift(newItem);
        items = items.filter(i => i.id !== targetFolder.id); items.unshift(targetFolder);
    } else {
        const newFolder = { id: Date.now() + 1, isFolder: true, name: folderName, items: [newItem] };
        items.unshift(newFolder);
    }

    localStorage.setItem(MDC_VOCAB_KEY, JSON.stringify(items));
}

/* === PILL LOGIC (UNIFIED) === */
function updateUnifiedPill(translationData = null) {
    const pill = document.getElementById('unified-pill');
    const statsText = document.getElementById('pill-stats-text');
    const transPart = document.getElementById('pill-trans');
    const divider = document.getElementById('pill-divider');
    const transOrigin = document.getElementById('trans-origin');
    const transResult = document.getElementById('trans-result');

    if (!currentStatsContext) { pill.classList.remove('visible'); return; }

    pill.classList.add('visible');

    // Stats ahora cuenta palabras guardadas INDIVIDUALES
    const savedElements = currentStatsContext.querySelectorAll('.interactive-word.saved');
    const uniqueSet = new Set();
    savedElements.forEach(el => uniqueSet.add(sanitizeText(el.innerText).toLowerCase()));
    
    currentWordStats.uniqueTotal = uniqueSet.size;
    currentWordStats.occurrences = savedElements.length;
    
    statsText.innerText = `${currentWordStats.occurrences} | ${currentWordStats.uniqueTotal}`;
    if(currentWordStats.uniqueTotal > 0) statsText.classList.add('stats-active');
    else statsText.classList.remove('stats-active');

    if (translationData) {
        divider.style.display = 'block';
        transPart.classList.add('active');
        transOrigin.innerText = translationData.origin;
        transResult.innerText = translationData.result;
    } else if (!transPart.dataset.hasActive) {
        divider.style.display = 'none';
        transPart.classList.remove('active');
    }
}

async function translateWord(text) {
    const transPart = document.getElementById('pill-trans');
    transPart.dataset.hasActive = "true"; 
    updateUnifiedPill({ origin: text.substring(0, 15) + "...", result: "..." });

    try {
        const res = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=es&dt=t&q=${encodeURIComponent(text)}`);
        const data = await res.json();
        let result = "Not found";
        if (data && data[0] && data[0][0]) result = data[0][0][0];
        updateUnifiedPill({ origin: text.substring(0, 15) + "...", result: result });
    } catch (e) { updateUnifiedPill({ origin: text, result: "Error" }); }
    
    clearTimeout(window.transTimer);
    window.transTimer = setTimeout(() => { 
        transPart.dataset.hasActive = ""; 
        updateUnifiedPill(null); 
    }, 5000);
}

// --- CORE INTERACTION LOGIC (ORIGINAL) ---
function toggleAccordion(id) {
    const content = document.getElementById(`content-${id}`);
    const isVisible = content.classList.contains('active');
    document.querySelectorAll('.accordion-content').forEach(c => c.classList.remove('active'));
    
    // Limpiar selecci√≥n manual
    document.querySelectorAll('.phrase-selecting').forEach(el => el.classList.remove('phrase-selecting'));
    document.querySelectorAll('.save-phrase-btn').forEach(btn => { btn.classList.remove('ready'); btn.innerHTML = "üíæ Save Phrase"; });

    if (!isVisible) {
        content.classList.add('active');
        setTimeout(refreshActiveView, 50); 
        currentStatsContext = content.querySelector('.interactive-content');
        currentWordStats.occurrences = "-";
        updateUnifiedPill(null); 
    } else {
        currentStatsContext = null;
        updateUnifiedPill(null); 
    }
}

function saveWordToMDC(word, element) {
    translateWord(word); 
    const cleanWord = sanitizeText(word);
    if (!cleanWord) return;

    let items = JSON.parse(localStorage.getItem(MDC_VOCAB_KEY) || '[]');
    const checkEng = cleanWord.toLowerCase();

    // Check Duplicates
    let wordFound = false;
    items.forEach(i => {
        if (!i.isFolder && i.eng && sanitizeText(i.eng).toLowerCase() === checkEng) wordFound = true;
        if (i.isFolder && i.items) {
            i.items.forEach(sub => { if (sub.eng && sanitizeText(sub.eng).toLowerCase() === checkEng) wordFound = true; });
        }
    });

    const accordionItem = element.closest('.accordion-item');
    const folderName = accordionItem ? accordionItem.querySelector('.header-content strong').innerText.trim() : "AI Generator";
    
    if (!wordFound) {
        // ESP: "" (VACIO)
        const newItem = { id: Date.now(), isFolder: false, eng: cleanWord, esp: "", isHighlighted: false, dateAdded: Date.now() };
        let targetFolder = items.find(i => i.isFolder && i.name.toLowerCase() === folderName.toLowerCase());

        if (targetFolder) {
            targetFolder.items.unshift(newItem);
            items = items.filter(i => i.id !== targetFolder.id); items.unshift(targetFolder);
        } else {
            const newFolder = { id: Date.now() + 1, isFolder: true, name: folderName, items: [newItem] };
            items.unshift(newFolder);
        }
    } else {
        items.forEach(folder => {
            if (folder.isFolder && folder.items) { folder.items = folder.items.filter(item => sanitizeText(item.eng).toLowerCase() !== checkEng); }
        });
        items = items.filter(i => i.isFolder || (i.eng && sanitizeText(i.eng).toLowerCase() !== checkEng));
    }

    localStorage.setItem(MDC_VOCAB_KEY, JSON.stringify(items));
    refreshActiveView();
}

/* === REST OF APP LOGIC === */
function loadVocabFolders() {
    const raw = localStorage.getItem(MDC_VOCAB_KEY);
    const group = document.getElementById('folder-group');
    const badge = document.getElementById('vocab-count-badge');
    if(!raw) { badge.innerText = "No DB"; badge.style.color = "#cf6679"; return; }
    const data = JSON.parse(raw);
    group.innerHTML = '';
    let total = 0;
    data.forEach(item => {
        if(item.isFolder) {
            let opt = document.createElement('option');
            opt.value = `folder:${item.id}`;
            opt.textContent = `${item.name} (${item.items.length})`;
            group.appendChild(opt);
            total += item.items.length;
        } else total++;
    });
    badge.innerText = `${total} words`;
    badge.style.color = "#00ffcc";
}

function toggleVocabMode() {
    const isActive = document.getElementById('useVocabCheckbox').checked;
    const settings = document.getElementById('vocab-settings');
    const controlsPanel = document.getElementById('vocab-controls');
    const topicInput = document.getElementById('topicInput');
    const taskSelect = document.getElementById('taskSelect');
    settings.style.display = isActive ? 'block' : 'none';
    if (isActive) {
        controlsPanel.classList.add('active-panel');
        loadVocabFolders(); 
        topicInput.value = "Target Vocabulary List"; 
        topicInput.disabled = true;
        taskSelect.innerHTML = '';
        VOCAB_TASKS.forEach(t => { let opt = document.createElement('option'); opt.value = t.id; opt.textContent = t.label; taskSelect.appendChild(opt); });
        syncModeWithTask(); 
    } else {
        controlsPanel.classList.remove('active-panel');
        topicInput.value = ""; topicInput.disabled = false;
        updateDynamicDropdowns(); 
    }
}

function syncModeWithTask() {
    if (!document.getElementById('useVocabCheckbox').checked) return;
    const taskId = document.getElementById('taskSelect').value;
    const task = VOCAB_TASKS.find(t => t.id === taskId);
    if (task && task.linkedMode) {
        document.getElementById('modeSelect').value = task.linkedMode;
    }
}

function getSelectedVocab() {
    if (!document.getElementById('useVocabCheckbox').checked) return null;
    const source = document.getElementById('vocabSource').value;
    const amount = parseInt(document.getElementById('vocabAmount').value);
    const raw = localStorage.getItem(MDC_VOCAB_KEY);
    if(!raw) return [];
    const data = JSON.parse(raw);
    let pool = [];
    if (source === 'all') { data.forEach(i => i.isFolder ? pool.push(...i.items) : pool.push(i)); } 
    else if (source === 'highlighted') { data.forEach(i => { if(i.isFolder) pool.push(...i.items.filter(x=>x.isHighlighted)); else if(i.isHighlighted) pool.push(i); }); } 
    else if (source.startsWith('folder:')) { const fid = parseInt(source.split(':')[1]); const f = data.find(i => i.id === fid); if(f) pool = f.items; }
    else if (source === 'recent') { let all = []; data.forEach(i => i.isFolder ? all.push(...i.items) : all.push(i)); all.sort((a,b) => b.id - a.id); pool = all.slice(0, 10); }
    if(pool.length === 0) return [];
    return pool.sort(() => 0.5 - Math.random()).slice(0, amount).map(i => i.eng);
}

function loadVoices() {
    availableVoices = window.speechSynthesis.getVoices().filter(v => v.lang.startsWith('en')); 
    document.querySelectorAll('.daw-select').forEach(sel => updateVoiceSelect(sel));
}

function updateVoiceSelect(select) {
    const savedVoiceURI = localStorage.getItem(PREF_AUDIO_VOICE);
    select.innerHTML = '';
    availableVoices.forEach(v => { const opt = document.createElement('option'); opt.value = v.voiceURI; opt.textContent = v.name.substring(0, 18); select.appendChild(opt); });
    if(savedVoiceURI) select.value = savedVoiceURI;
}

function updateAudioLive(id) {
    const speed = document.getElementById(`speed-${id}`).value;
    const voiceURI = document.getElementById(`voice-${id}`).value;
    localStorage.setItem(PREF_AUDIO_SPEED, speed);
    localStorage.setItem(PREF_AUDIO_VOICE, voiceURI);
    const screen = document.getElementById(`screen-${id}`);
    const voiceName = availableVoices.find(v => v.voiceURI === voiceURI)?.name.substring(0,6) || "DEF";
    if(screen) screen.innerText = `SPD:${speed}x | ${voiceName}`;
}

function speakContent(id) {
    window.speechSynthesis.cancel();
    const contentDiv = document.querySelector(`#content-${id} .interactive-content`);
    const text = contentDiv.innerText;
    const speed = document.getElementById(`speed-${id}`).value;
    const voiceURI = document.getElementById(`voice-${id}`).value;
    const utter = new SpeechSynthesisUtterance(text);
    const selectedVoice = availableVoices.find(v => v.voiceURI === voiceURI);
    if(selectedVoice) utter.voice = selectedVoice;
    utter.rate = parseFloat(speed);
    const playBtn = document.getElementById(`play-${id}`);
    const screen = document.getElementById(`screen-${id}`);
    utter.onstart = () => { playBtn.classList.add('playing'); playBtn.innerHTML = '‚óè'; if(screen) screen.classList.add('active'); };
    utter.onend = () => { playBtn.classList.remove('playing'); playBtn.innerHTML = '‚ñ∂'; if(screen) screen.classList.remove('active'); };
    window.speechSynthesis.speak(utter);
}

function toggleAudio(id) {
    const btn = document.getElementById(`play-${id}`);
    if(!btn.classList.contains('playing')) speakContent(id); else window.speechSynthesis.cancel();
}

function loadNexusHistory() {
    const stored = localStorage.getItem(NEXUS_STORAGE_KEY);
    if (stored) { nexusHistory = JSON.parse(stored); [...nexusHistory].reverse().forEach(data => renderAccordionDOM(data)); }
}
function saveNexusState() { localStorage.setItem(NEXUS_STORAGE_KEY, JSON.stringify(nexusHistory)); }
function addToNexusHistory(data) { nexusHistory.unshift(data); saveNexusState(); }
function removeFromNexusHistory(id) { nexusHistory = nexusHistory.filter(item => item.id !== id); saveNexusState(); }

function formatInteractiveContent(text) {
    if (!text) return "";
    const safeText = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    let i = 0; // √çndice para ordenamiento de frases
    return safeText.split(/(\s+)/).map(token => {
        if (token.match(/^\s+$/)) return token; 
        const span = `<span class="interactive-word" data-idx="${i}" 
            onmousedown="startPress(this)" 
            ontouchstart="startPress(this)" 
            onmouseup="endPress(this, event)" 
            ontouchend="endPress(this, event)"
            onclick="handleShortClick(this)">${token}</span>`;
        i++;
        return span;
    }).join('');
}

function renderAccordionDOM(data) {
    const container = document.getElementById('results-container');
    const item = document.createElement('div');
    item.className = 'accordion-item';
    item.id = `item-${data.id}`;
    const interactiveHTML = formatInteractiveContent(data.content);
    const savedSpeed = localStorage.getItem(PREF_AUDIO_SPEED) || "1";

    item.innerHTML = `
        <div class="accordion-header" onclick="toggleAccordion(${data.id})">
            <div class="header-content">
                <span class="meta-tag">${data.modeName}</span>
                <strong>${data.topic}</strong>
            </div>
            <div class="header-actions">
                <button class="btn-delete" onclick="deleteItem(event, ${data.id})">üóëÔ∏è</button>
                <span>‚ñº</span>
            </div>
        </div>
        <div class="accordion-content" id="content-${data.id}">
            <div class="daw-panel">
                <div class="daw-top-deck">
                    <button id="play-${data.id}" class="daw-btn-play" onclick="toggleAudio(${data.id})">‚ñ∂</button>
                    <div class="daw-screen" id="screen-${data.id}">MASTER OUT</div>
                </div>
                <div class="daw-control-deck">
                    <div class="daw-knob-group">
                        <span class="daw-label">SPEED</span>
                        <input type="range" id="speed-${data.id}" class="daw-slider" min="0.5" max="2.0" step="0.1" value="${savedSpeed}" oninput="updateAudioLive(${data.id})">
                    </div>
                    <div class="daw-knob-group">
                        <span class="daw-label">VOICE BANK</span>
                        <select id="voice-${data.id}" class="daw-select" onchange="updateAudioLive(${data.id})"></select>
                    </div>
                </div>
            </div>
            <div class="action-row">
                <button class="save-phrase-btn" onclick="savePhraseSelection(this)">üíæ Save Phrase</button>
            </div>
            <button class="copy-prompt-btn" onclick="copyTextToClipboard(this)">üìú Copy Prompt</button>
            <div style="display:none;" class="prompt-source">${data.prompt}</div>
            <hr style="border:0; border-top:1px solid #444; margin:10px 0;">
            <div class="interactive-content" style="white-space: pre-wrap;">${interactiveHTML}</div>
        </div>
    `;

    if(document.getElementById(`item-${data.id}`)) return;
    if (container.firstChild) container.insertBefore(item, container.firstChild);
    else container.appendChild(item);

    setTimeout(() => { updateVoiceSelect(document.getElementById(`voice-${data.id}`)); }, 100);
}

function toggleAlgorithmMode() {
    const isComplex = document.getElementById('modeSwitch').checked;
    const vocabCheck = document.getElementById('useVocabCheckbox');
    if(vocabCheck.checked) { vocabCheck.checked = false; toggleVocabMode(); }
    if (isComplex) {
        currentData = ALGORITHMS.COMPLEX;
        document.getElementById('labelSimple').classList.remove('active');
        document.getElementById('labelComplex').classList.add('active');
    } else {
        currentData = ALGORITHMS.SIMPLEX;
        document.getElementById('labelSimple').classList.add('active');
        document.getElementById('labelComplex').classList.remove('active');
    }
    updateDynamicDropdowns();
}

function updateDynamicDropdowns() {
    if (!document.getElementById('useVocabCheckbox').checked) { populateSelect('taskSelect', currentData.TASK_TYPES); }
    populateSelect('voiceSelect', currentData.VOICES);
    populateSelect('lengthSelect', currentData.LENGTH);
    const levelSel = document.getElementById('levelSelect');
    levelSel.innerHTML = '';
    currentData.FADER_LEVELS.forEach((level) => { let opt = document.createElement('option'); opt.value = level; opt.textContent = level.split(':')[0]; levelSel.appendChild(opt); });
}

function populateSelect(id, dataArray) {
    const select = document.getElementById(id);
    select.innerHTML = '';
    dataArray.forEach(item => { let opt = document.createElement('option'); opt.value = item.id; opt.textContent = item.label; select.appendChild(opt); });
}

function loadHistory(inputId, listId) {
    const history = JSON.parse(localStorage.getItem(inputId + '_mem')) || [];
    const dataList = document.getElementById(listId);
    if(dataList) { dataList.innerHTML = ''; history.forEach(item => { let option = document.createElement('option'); option.value = item; dataList.appendChild(option); }); }
}

function saveToHistory(inputId) {
    const input = document.getElementById(inputId);
    const value = input.value.trim();
    if (!value) return;
    let history = JSON.parse(localStorage.getItem(inputId + '_mem')) || [];
    history = history.filter(item => item !== value);
    history.unshift(value);
    if (history.length > 5) history.pop();
    localStorage.setItem(inputId + '_mem', JSON.stringify(history));
    loadHistory(inputId, input.getAttribute('list'));
}

function generatePrompt() {
    const isVocabMode = document.getElementById('useVocabCheckbox').checked;
    let context = document.getElementById('contextInput').value;
    let topic = document.getElementById('topicInput').value;
    let vocabBlock = "";
    let selectedTask = null;

    if (isVocabMode) {
        const words = getSelectedVocab();
        if (words && words.length > 0) {
            vocabBlock = `\n<target_vocabulary_list>\n${words.join(', ')}\n</target_vocabulary_list>\n\n**MANDATORY INSTRUCTION:** 1. You MUST incorporate the words inside the <target_vocabulary_list> tags into your response.\n2. Formatting Rule: Mark every used word in **bold** (e.g., **word**).\n`;
            topic = "English Vocabulary Practice"; 
            const taskId = document.getElementById('taskSelect').value;
            selectedTask = VOCAB_TASKS.find(t => t.id === taskId);
            if(!selectedTask) selectedTask = VOCAB_TASKS[0];
        } else { alert("No vocabulary found! Add words in the MDC App."); return; }
    } else { selectedTask = currentData.TASK_TYPES.find(t => t.id === document.getElementById('taskSelect').value); }

    const mode = COMMON_DATA.MODES.find(m => m.id === document.getElementById('modeSelect').value);
    const format = COMMON_DATA.FORMATS.find(f => f.id === document.getElementById('formatSelect').value);
    const voice = currentData.VOICES.find(v => v.id === document.getElementById('voiceSelect').value);
    const len = currentData.LENGTH.find(l => l.id === document.getElementById('lengthSelect').value);
    const level = document.getElementById('levelSelect').value;

    const prompt = `
# SYSTEM IDENTITY & CORE OBJECTIVE
You are an advanced AI acting strictly as: **${mode.role}**
Your style must be: ${mode.style}
**Primary Goal:** ${mode.goal}

# PROJECT CONTEXT
I need you to perform a specific task based on the following parameters:
- **Context:** ${context || "General"}
- **Subject/Topic:** ${topic}
- **Task Type:** ${selectedTask.label} -> ${selectedTask.instruction}

${vocabBlock ? `\n# MANDATORY DATA (Vocabulary)${vocabBlock}\n` : ''}

# RESPONSE GUIDELINES
Follow these configuration rules strictly:
1. **Format:** ${format.label} (${format.instruction})
2. **Tone:** ${voice.instruction}
3. **Length:** ${len.instruction}
4. **Depth Level:** ${level}

# CRITICAL INSTRUCTIONS & RESTRICTIONS
To ensure high quality, follow this logic:
- Think step-by-step before generating.
- Analyze the "${topic}" within the context of "${context}".
- ${currentData.RESTRICTIONS.join('\n- ')}

---
**BEGIN RESPONSE:**`.trim();

    const outputDiv = document.getElementById('prompt-output');
    outputDiv.style.display = 'block';
    outputDiv.textContent = prompt;
    navigator.clipboard.writeText(prompt);
    lastGeneratedPrompt = prompt;
    if(!isVocabMode) { saveToHistory('contextInput'); saveToHistory('topicInput'); }
}

async function handlePasteResponse() {
    try {
        const text = await navigator.clipboard.readText();
        if(!text) return alert("Clipboard is empty.");
        const data = {
            id: Date.now(),
            modeName: document.getElementById('modeSelect').options[document.getElementById('modeSelect').selectedIndex].text,
            topic: document.getElementById('topicInput').value || "Untitled Result",
            prompt: lastGeneratedPrompt,
            content: text
        };
        addToNexusHistory(data);
        renderAccordionDOM(data);
        toggleGenerator(false);
    } catch (err) { alert("Permission denied or error reading clipboard."); }
}

function toggleGenerator(show) {
    const gen = document.getElementById('generator-container');
    const btnShow = document.getElementById('btn-show-gen');
    if (show) { gen.classList.remove('hidden'); btnShow.style.display = 'none'; } 
    else { gen.classList.add('hidden'); btnShow.style.display = 'block'; }
}

function deleteItem(event, id) {
    event.stopPropagation();
    if(confirm("Delete result?")) {
        const el = document.getElementById(`item-${id}`);
        if(el) el.remove();
        removeFromNexusHistory(id);
    }
}

function copyTextToClipboard(btnElement) {
    const promptText = btnElement.nextElementSibling.textContent;
    navigator.clipboard.writeText(promptText).then(() => {
        const originalText = btnElement.innerText;
        btnElement.innerText = "Copied!";
        setTimeout(() => btnElement.innerText = originalText, 1500);
    });
}

function filterResults() {
    const query = document.getElementById('searchBar').value.toLowerCase();
    const items = document.querySelectorAll('.accordion-item');
    items.forEach(item => {
        const topic = item.querySelector('.header-content strong').innerText.toLowerCase();
        const content = item.querySelector('.interactive-content').innerText.toLowerCase();
        if (topic.includes(query) || content.includes(query)) item.style.display = "block";
        else item.style.display = "none";
    });
}
</script>
</body>
</html>
