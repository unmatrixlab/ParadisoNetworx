<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Scribe's Shelf: Typing Defense</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; overflow: hidden; background: #050505; 
            font-family: 'Press Start 2P', monospace; color: white; user-select: none;
        }
        canvas { display: block; }
        
        /* UI Overlays */
        #ui { 
            position: absolute; top: 20px; left: 20px; right: 20px; z-index: 10; 
            pointer-events: none; display: flex; justify-content: space-between;
        }
        #lives-panel { color: #ff4444; }

        /* INPUT BAR */
        #input-bar {
            position: absolute; bottom: 0; left: 0; right: 0; height: 50px;
            background: rgba(0, 0, 0, 0.85); z-index: 15;
            display: flex; justify-content: center; align-items: center;
            border-top: 2px solid #00ff00;
        }
        #typing-input {
            width: 80%; max-width: 500px;
            background: #111; color: #00ff00;
            border: 2px solid #009900; padding: 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 14px; text-transform: uppercase;
            outline: none;
            text-align: center;
        }
        #input-bar label { color: #fff; font-size: 10px; margin-right: 10px;}

        /* CATEGORY BAR */
        #category-bar-wrapper {
            position: absolute; bottom: 50px; left: 0; width: 100%;
            padding: 5px 0; background: rgba(0, 0, 0, 0.5);
            z-index: 15;
            overflow-x: scroll; white-space: nowrap; display: flex;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.4);
        }
        .category-chip {
            padding: 6px 12px; margin: 0 5px; background: #111; color: #444;
            font-size: 10px; cursor: pointer; border: 1px solid #444; transition: 0.2s;
            pointer-events: all; display: inline-block;
        }
        .category-chip.active { color: #00ff00; background: #003300; border-color: #00ff00; text-shadow: 0 0 5px #00ff00; }


        /* SCREENS */
        #start-screen, #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.85); z-index: 20; text-align: center;
        }
        h1 { color: #00ff00; text-shadow: 4px 4px #003300; font-size: 35px; margin-bottom: 20px; line-height: 1.5; }
        h2 { color: #ff0000; font-size: 25px; margin-top: 50px; }
        p { line-height: 2; color: #aaa; font-size: 10px; max-width: 600px;}
        .blink { animation: blinker 1s linear infinite; color: #ffff00; margin-top: 30px; font-size: 14px; cursor: pointer;}
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>

    <div id="ui">
        <div id="score-panel">SCORE: <span id="score">0</span> | COMBO: <span id="combo">0</span></div>
        <div id="lives-panel">LIVES: <span id="lives">5</span></div>
        <div id="high-score-panel">HIGH SCORE: <span id="highScore">0</span></div>
    </div>
    
    <div id="category-bar-wrapper"></div>

    <div id="input-bar">
        <input type="text" id="typing-input" placeholder="TYPE THE ANSWER AND PRESS ENTER">
    </div>

    <div id="start-screen" onclick="startGame()">
        <h1>SCRIBE'S SHELF</h1>
        <p>
            GOAL: Type the correct word to match the sequence before enemies disappear.<br>
            <br>
            SEQUENCE:<br>
            1. **(White) ENGLISH** → Type SPANISH.<br>
            2. **(Green) SPANISH** → Type SYNONYM.<br>
            3. **(Yellow) SYNONYM** → Type ORIGINAL ENGLISH.<br>
            4. **(Blue) ENGLISH** → Type ENGLISH (Final Match).<br>
        </p>
        <div class="blink">CLICK TO START</div>
    </div>

    <div id="game-over-screen" style="display:none;" onclick="startGame()">
        <h2>GAME OVER</h2>
        <p>FINAL SCORE: <span id="finalScore">0</span></p>
        <p>NEW HIGH SCORE: <span id="newHighScore" style="color: #00ff00;">NO</span></p>
        <div class="blink">CLICK TO RETRY</div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/* --- BASE DE DATOS MODULARIZADA (Rich Vocabulary) --- */
const wordsDB = {
    'NOUNS': [
        {en: "MALAISE", es: ["MALESTAR", "INDISPOSICIÓN", "DECAIMIENTO"]},
        {en: "CULMINATION", es: ["EPÍLOGO", "CESE", "PERORATA"]},
        {en: "AVARICE", es: ["CODICIA", "USURA", "CAJETERÍA"]},
        {en: "MENDICANT", es: ["INDIGENTE", "MENDIGO", "LIMOSNERO"]},
        {en: "TREPIDATION", es: ["TEMOR", "MIEDO", "RECELO"]}
    ],
    'VERBS': [
        {en: "PREVARICATE", es: ["ENGAÑAR", "EVASIVA", "MENTIR"]},
        {en: "ESCHEW", es: ["EVITAR", "REHUIR", "ELUDIR"]},
        {en: "JETTISON", es: ["DESECHAR", "ABANDONAR", "DESCARTAR"]},
        {en: "DENIGRATE", es: ["DIFAMAR", "CALUMNIAR", "VILIPENDIAR"]},
        {en: "UPBRAID", es: ["CRITICAR", "REPRENDER", "RECENSURAR"]}
    ],
    'ADJECTIVES': [
        {en: "PLIABLE", es: ["DÚCTIL", "MOLDEABLE", "FLEXIBLE"]},
        {en: "ERUDITE", es: ["DOCTO", "VERSADO", "SABIO"]},
        {en: "LACONIC", es: ["CONCISO", "SUCINTO", "BREVE"]},
        {en: "STOLID", es: ["IMPÁVIDO", "IMPONENTE", "APLOMADO"]},
        {en: "SANGUINE", es: ["OPTIMISTA", "ENTUSIASTA", "VITAL"]}
    ]
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const comboEl = document.getElementById('combo');
const livesEl = document.getElementById('lives');
const highScoreEl = document.getElementById('highScore');
const typingInput = document.getElementById('typing-input');
const categoryBarWrapper = document.getElementById('category-bar-wrapper');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');

/* --- AUDIO ENGINE --- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let musicInterval;

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;

    if (type === 'hit_correct') { 
        osc.type = 'sine'; osc.frequency.setValueAtTime(880, now); osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1); gain.gain.setValueAtTime(0.08, now); gain.gain.linearRampToValueAtTime(0, now + 0.15); osc.start(now); osc.stop(now + 0.15);
    } else if (type === 'hit_review') { 
        osc.type = 'square'; osc.frequency.setValueAtTime(440, now); gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.15);
    } else if (type === 'hit_final') {
        osc.type = 'triangle'; osc.frequency.setValueAtTime(1500, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3);
    } else if (type === 'hit_fail') { 
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(50, now + 0.3); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5);
    }
}

function startMusic() {
    let step = 0;
    const melody = [110, 0, 130, 0, 164, 0, 130, 0];
    if(musicInterval) clearInterval(musicInterval);
    musicInterval = setInterval(() => {
        if(melody[step] > 0) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'triangle';
            osc.frequency.value = melody[step] * 0.5;
            gain.gain.value = 0.02;
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.25);
        }
        step = (step + 1) % melody.length;
    }, 400);
}

/* --- GAME STATE & ENTITIES --- */
let gameRunning = false;
let score = 0;
let combo = 0;
let lives = 5;
let highScore = 0;
let lastTime = 0;
let currentCategory = 'NOUNS'; 

const SPAWN_INTERVAL = 3000; 
let spawnTimer = SPAWN_INTERVAL; 

let enemies = [];
let particles = [];
let stars = [];
let isInvincible = false;

// Cargar High Score
function loadHighScore() {
    const savedScore = localStorage.getItem('scribeShelfHighScore');
    highScore = savedScore ? parseInt(savedScore) : 0;
    highScoreEl.innerText = highScore;
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);


function spawnEnemy() {
    const categoryWords = wordsDB[currentCategory];
    if (!categoryWords || categoryWords.length === 0) return;

    const data = categoryWords[Math.floor(Math.random() * categoryWords.length)];
    
    // Path: Always S1, then S2 or S3 (random choice of 1 or 2 index)
    const synonymIndex = (Math.random() < 0.5) ? 1 : 2; 

    ctx.font = '16px "Press Start 2P"'; 
    const textWidth = ctx.measureText(data.en).width * 1.2;

    enemies.push({
        x: canvas.width + 50, // Start off-screen right
        y: Math.random() * (canvas.height - 150) + 50, // Y position
        wordData: data,
        text: data.en,
        stage: 0, // 0:EN, 1:SP1, 2:SP2/SP3, 3:EN_Review, 4:Fading
        synonymIndex: synonymIndex,
        speed: 0.5 + (score / 1500), // Speed increases with score
        color: '#ffffff',
        timer: 0, // Life timer
        w: textWidth
    });
}

function createExplosion(x, y, color, count=10) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 1.0,
            color: color
        });
    }
}

// Determines the required input based on the word's current state
function getRequiredAnswer(enemy) {
    switch (enemy.stage) {
        case 0: return enemy.wordData.es[0].toLowerCase().replace(/_/g, ' '); // EN -> SP1 (Primary Translation)
        case 1: return enemy.wordData.es[enemy.synonymIndex].toLowerCase().replace(/_/g, ' '); // SP1 -> SP2/SP3 (Synonym)
        case 2: return enemy.wordData.en.toLowerCase(); // SP2/SP3 -> EN (Review)
        case 3: return enemy.wordData.en.toLowerCase(); // EN -> EN (Final Match)
        default: return "";
    }
}

// Logic triggered by correct typing
function advanceEnemyStage(enemy) {
    enemy.stage++;
    enemy.timer = 0; // Reset life timer

    if (enemy.stage === 1) { 
        enemy.text = enemy.wordData.es[0];
        enemy.color = '#00ff00'; // Green
        playSound('hit_correct');
        score += 10;
    } else if (enemy.stage === 2) { 
        enemy.text = enemy.wordData.es[enemy.synonymIndex];
        enemy.color = '#ffff00'; // Yellow
        createExplosion(enemy.x, enemy.y, '#ffff00', 15);
        playSound('hit_correct');
        score += 50;
        combo++;
    } else if (enemy.stage === 3) { 
        enemy.text = enemy.wordData.en;
        enemy.color = '#4f46e5'; // Blue/Review
        createExplosion(enemy.x, enemy.y, '#4f46e5', 10);
        playSound('hit_review');
        score += 100;
        combo++;
    } else if (enemy.stage === 4) { // FINAL HIT
        enemy.fading = true;
        createExplosion(enemy.x, enemy.y, '#ffffff', 30);
        playSound('hit_final');
        score += 150;
        combo++;
    }
}

// Handles user input submission
function checkAnswer() {
    const inputVal = typingInput.value.trim().toUpperCase();
    if (!inputVal) return;

    let targetIndex = -1;
    let lowestX = Infinity;

    // Find the enemy closest to the 'void' (left side)
    for (let i = 0; i < enemies.length; i++) {
        // Only target words currently visible/on-screen
        if (!enemies[i].fading && enemies[i].x < lowestX) { 
            lowestX = enemies[i].x;
            targetIndex = i;
        }
    }

    if (targetIndex !== -1) {
        const target = enemies[targetIndex];
        const required = getRequiredAnswer(target).toUpperCase();

        if (inputVal === required) {
            advanceEnemyStage(target);
            typingInput.value = ''; // Clear on success
        } else {
            // Failure logic (Misspelling)
            lives--;
            livesEl.innerText = lives;
            typingInput.style.borderColor = '#ff4444';
            setTimeout(() => typingInput.style.borderColor = '#009900', 200);
            playSound('hit_fail');
            combo = 0;
            comboEl.innerText = combo;

            if (lives <= 0) {
                gameOver();
            }
        }
    }
}

document.addEventListener('keydown', e => {
    // Submit on Enter key press
    if (e.key === 'Enter' && gameRunning) {
        checkAnswer();
    }
    // Ensure the input field has focus when typing starts
    if (gameRunning && e.key.length === 1 && e.key.match(/[a-z0-9 ]/i)) {
        typingInput.focus();
    }
});


function update(dt) {
    if (!gameRunning) return;

    spawnTimer -= dt;
    if (spawnTimer < 0) { spawnEnemy(); spawnTimer = SPAWN_INTERVAL; }

    // Background Stars
    stars.forEach(s => { s.y += s.speed; if(s.y > canvas.height) s.y = 0; });

    // Enemies (Words) move left)
    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];

        if (!e.fading) {
            e.x -= e.speed;
            
            // Life timer update
            if (e.stage >= 1) { 
                e.timer += dt;
                if (e.timer > 3000) { e.fading = true; } 
            }
        } else {
            createExplosion(e.x, e.y, e.color, 1);
            enemies.splice(i, 1);
            continue;
        }

        // Enemy reaches the end (The Void)
        if (e.x < -100) {
            lives--;
            livesEl.innerText = lives;
            enemies.splice(i, 1); 
            combo = 0;
            comboEl.innerText = combo;

            if (lives <= 0) {
                gameOver();
                return;
            }
        }
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.life -= 0.04;
        if(p.life <= 0) particles.splice(i, 1);
    }
}

function draw() {
    ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    stars.forEach(s => {
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
    });

    if(!gameRunning) {
        requestAnimationFrame(draw);
        return;
    }

    // Enemies (Words)
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    enemies.forEach(e => {
        ctx.font = e.stage >= 1 ? '20px "Press Start 2P"' : '16px "Press Start 2P"';
        ctx.fillStyle = e.color;
        
        // Shadow/Glow effect for translated words
        if (e.stage >= 1) { ctx.shadowBlur = 10; ctx.shadowColor = e.color; }
        ctx.fillText(e.text, e.x, e.y);
        ctx.shadowBlur = 0;
        
        // Life/Stage dots
        for(let k=0; k<4; k++) {
            ctx.fillStyle = k < e.stage ? '#00ff00' : '#444'; 
            ctx.beginPath();
            ctx.arc(e.x - 22 + (k*15), e.y + 25, 3, 0, Math.PI*2);
            ctx.fill();
        }
    });

    // Particles
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fillRect(p.x, p.y, 3, 3);
        ctx.globalAlpha = 1;
    });

    requestAnimationFrame(() => {
        const now = performance.now();
        const delta = now - lastTime;
        lastTime = now;
        update(delta);
        draw();
    });
}


function gameOver() {
    gameRunning = false;
    clearInterval(musicInterval);
    
    const isNewHighScore = score > highScore;
    if (isNewHighScore) {
        highScore = score;
        localStorage.setItem('scribeShelfHighScore', highScore);
        highScoreEl.innerText = highScore;
    }

    document.getElementById('finalScore').innerText = score;
    document.getElementById('newHighScore').innerText = isNewHighScore ? 'YES!' : 'NO';
    gameOverScreen.style.display = 'flex';
}

// --- CATEGORIES LOGIC ---
function renderCategoryBar() {
    categoryBarWrapper.innerHTML = '';
    const categories = Object.keys(wordsDB);
    
    categories.forEach(category => {
        const chip = document.createElement('div');
        chip.className = 'category-chip';
        chip.textContent = category.toUpperCase();
        chip.onclick = () => setCategory(category);
        
        if (category === currentCategory) {
            chip.classList.add('active');
        }
        categoryBarWrapper.appendChild(chip);
    });
}

function setCategory(category) {
    currentCategory = category;
    renderCategoryBar(); 
    
    if (gameRunning) {
        spawnTimer = 500; 
        enemies = []; 
        typingInput.value = '';
    }
}


function startGame() {
    if (!gameRunning) {
        resize();
        loadHighScore();

        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';
        gameRunning = true;
        
        score = 0; 
        combo = 0;
        lives = 5;
        enemies.length = 0; 
        particles.length = 0;
        
        scoreEl.innerText = '0';
        comboEl.innerText = '0';
        livesEl.innerText = '5';
        
        renderCategoryBar();
        
        lastTime = performance.now();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        startMusic();
        draw();
        typingInput.focus(); // Focus input on game start
    }
}

// Initial setup
window.addEventListener('load', () => {
    resize();
    renderCategoryBar();
    loadHighScore();
});

</script>
</body>
</html>
