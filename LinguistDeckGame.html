<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Synonym Hunter: Neon Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-green: #0f0;
            --neon-red: #ff4444;
            --neon-blue: #4f46e5;
            --neon-yellow: #ffff00;
            --dark-bg: #050505;
        }

        body { 
            margin: 0; overflow: hidden; background: var(--dark-bg); 
            font-family: 'Press Start 2P', monospace; color: white; user-select: none;
        }
        canvas { display: block; }
        
        /* CRT SCANLINES */
        .scanlines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            z-index: 999; pointer-events: none;
        }

        #ui { 
            position: absolute; top: 20px; left: 20px; right: 20px; z-index: 10; 
            pointer-events: none; display: flex; justify-content: space-between;
            text-shadow: 2px 2px 0 #000;
        }
        #lives-panel { color: var(--neon-red); }
        #score-panel { color: var(--neon-green); }
        
        /* CATEGORY BAR */
        #category-bar-wrapper {
            position: absolute; bottom: 30px; left: 0; width: 100%;
            padding: 10px 0; background: rgba(0, 0, 0, 0.8);
            z-index: 15;
            overflow-x: auto; white-space: nowrap;
            display: flex; justify-content: center;
            border-top: 1px solid #333;
            box-shadow: 0 -5px 15px rgba(0, 255, 0, 0.1);
        }
        .category-chip {
            padding: 8px 16px; margin: 0 8px;
            background: #111; color: #666;
            font-size: 10px; cursor: pointer;
            border: 1px solid #444;
            transition: 0.2s;
            pointer-events: all;
            display: inline-block;
        }
        .category-chip:hover { border-color: #888; color: #888; }
        .category-chip.active {
            color: var(--neon-green);
            background: #002200;
            border-color: var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
        }

        /* SCREENS */
        #start-screen, #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.92); z-index: 20; text-align: center;
        }
        h1 { color: var(--neon-green); text-shadow: 4px 4px #003300; font-size: 35px; margin-bottom: 20px; line-height: 1.5; }
        h2 { color: var(--neon-red); font-size: 30px; margin-bottom: 20px; text-shadow: 3px 3px 0 #300; }
        p { line-height: 2; color: #aaa; font-size: 12px; max-width: 600px; padding: 0 20px; }
        
        .key-hint { 
            display: inline-block; padding: 2px 6px; 
            border: 1px solid #666; border-radius: 4px; 
            color: #fff; background: #222; font-size: 10px;
        }

        .blink { animation: blinker 1s linear infinite; color: var(--neon-yellow); margin-top: 40px; font-size: 14px; cursor: pointer;}
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>

    <div class="scanlines"></div>

    <div id="ui">
        <div id="score-panel">SCORE: <span id="score">0</span> | COMBO: <span id="combo">0</span></div>
        <div id="lives-panel">LIVES: <span id="lives">5</span></div>
        <div id="high-score-panel">HIGH: <span id="highScore">0</span></div>
    </div>
    
    <div id="category-bar-wrapper"></div>

    <div id="start-screen" onclick="startGame()">
        <h1>SYNONYM HUNTER</h1>
        <p>
            1. Enemies descend with English words.<br>
            2. Shoot to cycle them through translations.<br>
            3. Cycle: EN &rarr; SP (Primary) &rarr; SP (Synonym) &rarr; EN &rarr; DESTROY<br><br>
            <span class="key-hint">ARROWS</span> Move &nbsp;&nbsp; <span class="key-hint">SPACE</span> Shoot
        </p>
        <div class="blink">CLICK TO START MISSION</div>
    </div>

    <div id="game-over-screen" style="display:none;" onclick="startGame()">
        <h2>MISSION FAILED</h2>
        <p>FINAL SCORE: <span id="finalScore" style="color:white;">0</span></p>
        <p>NEW HIGH SCORE: <span id="newHighScore" style="color: var(--neon-green);">NO</span></p>
        <div class="blink">CLICK TO RETRY</div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/* --- DATABASE (Extendable) --- */
const wordsDB = {
    'NOUNS': [
        {en: "MALAISE", es: ["MALESTAR", "INDISPOSICIÓN", "DECAIMIENTO"]},
        {en: "CULMINATION", es: ["EPÍLOGO", "CESE", "PERORATA"]},
        {en: "AVARICE", es: ["CODICIA", "USURA", "CAJETERÍA"]},
        {en: "MENDICANT", es: ["INDIGENTE", "MENDIGO", "LIMOSNERO"]},
        {en: "TREPIDATION", es: ["TEMOR", "MIEDO", "RECELO"]}
    ],
    'VERBS': [
        {en: "PREVARICATE", es: ["ENGAÑAR", "EVASIVA", "MENTIR"]},
        {en: "ESCHEW", es: ["EVITAR", "REHUIR", "ELUDIR"]},
        {en: "JETTISON", es: ["DESECHAR", "ABANDONAR", "DESCARTAR"]},
        {en: "DENIGRATE", es: ["DIFAMAR", "CALUMNIAR", "VILIPENDIAR"]},
        {en: "UPBRAID", es: ["CRITICAR", "REPRENDER", "RECENSURAR"]}
    ],
    'ADJECTIVES': [
        {en: "PLIABLE", es: ["DÚCTIL", "MOLDEABLE", "FLEXIBLE"]},
        {en: "ERUDITE", es: ["DOCTO", "VERSADO", "SABIO"]},
        {en: "LACONIC", es: ["CONCISO", "SUCINTO", "BREVE"]},
        {en: "STOLID", es: ["IMPÁVIDO", "IMPONENTE", "APLOMADO"]},
        {en: "SANGUINE", es: ["OPTIMISTA", "ENTUSIASTA", "VITAL"]}
    ]
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const comboEl = document.getElementById('combo');
const livesEl = document.getElementById('lives');
const highScoreEl = document.getElementById('highScore');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const categoryBarWrapper = document.getElementById('category-bar-wrapper');

/* --- AUDIO ENGINE --- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let musicInterval;

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;

    if (type === 'shoot') {
        osc.type = 'square'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.1); osc.start(now); osc.stop(now + 0.1);
    } else if (type === 'hit_eng') { 
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(600, now); osc.frequency.linearRampToValueAtTime(800, now + 0.1); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.15); osc.start(now); osc.stop(now + 0.15);
    } else if (type === 'hit_syn') {
        osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.linearRampToValueAtTime(1800, now + 0.1); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3);
    } else if (type === 'hit_review') { 
        osc.type = 'square'; osc.frequency.setValueAtTime(440, now); gain.gain.setValueAtTime(0.08, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.15);
    } else if (type === 'player_hit') { 
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(120, now); osc.frequency.linearRampToValueAtTime(80, now + 0.3); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5);
    }
}

function startMusic() {
    let step = 0;
    const melody = [220, 0, 261, 0, 329, 0, 261, 0];
    if(musicInterval) clearInterval(musicInterval);
    musicInterval = setInterval(() => {
        if(melody[step] > 0) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'triangle';
            osc.frequency.value = melody[step] * 0.5;
            gain.gain.value = 0.02;
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.25);
        }
        step = (step + 1) % melody.length;
    }, 200);
}


/* --- GAME STATE --- */
let gameRunning = false;
let score = 0;
let combo = 0;
let lives = 5;
let highScore = 0;
let lastTime = 0;
let currentCategory = 'NOUNS'; 

const SPAWN_INTERVAL = 3500; 
let spawnTimer = SPAWN_INTERVAL; 

const player = { x: 0, y: 0, w: 40, h: 40, speed: 8, color: '#4f46e5', invincible: false, invTimer: 0 };
let bullets = [];
let enemies = [];
let particles = [];
let stars = [];
const keys = {};

function loadHighScore() {
    const savedScore = localStorage.getItem('synonymHunterHighScore');
    highScore = savedScore ? parseInt(savedScore) : 0;
    highScoreEl.innerText = highScore;
}
loadHighScore(); 

/* --- CATEGORY LOGIC --- */

function renderCategoryBar() {
    categoryBarWrapper.innerHTML = '';
    const categories = Object.keys(wordsDB);
    
    categories.forEach(category => {
        const chip = document.createElement('div');
        chip.className = 'category-chip';
        chip.textContent = category;
        chip.onclick = () => setCategory(category);
        
        if (category === currentCategory) {
            chip.classList.add('active');
        }
        categoryBarWrapper.appendChild(chip);
    });
}

function setCategory(category) {
    currentCategory = category;
    renderCategoryBar(); 
    
    if (gameRunning) {
        spawnTimer = 500; 
        enemies.forEach(e => e.fading = true); // Clear screen gracefully
    }
}

/* --- INIT & LOOP --- */

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    player.y = canvas.height - 80; // Raised slightly to accommodate bottom bar
    player.x = canvas.width / 2 - player.w / 2;
}

window.addEventListener('resize', resize);

for(let i=0; i<80; i++) {
    stars.push({
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        size: Math.random() * 2,
        speed: Math.random() * 0.2 + 0.1
    });
}

function spawnEnemy() {
    const categoryWords = wordsDB[currentCategory];
    if (!categoryWords || categoryWords.length === 0) return;

    const data = categoryWords[Math.floor(Math.random() * categoryWords.length)];
    
    let indices = [1, 2].sort(() => Math.random() - 0.5); 
    const synonymPath = [0, indices[0]]; 

    ctx.font = '16px "Press Start 2P"'; 
    const textWidth = ctx.measureText(data.en).width;

    enemies.push({
        x: Math.random() * (canvas.width - textWidth - 50) + textWidth/2 + 25,
        y: -40,
        wordData: data,
        text: data.en,
        stage: 0, // 0:EN, 1:SP1, 2:SP2/SP3, 3:EN_Review, 4:Fading
        synonymPath: synonymPath,
        speed: Math.random() * 0.8 + 0.4,
        color: '#ffffff',
        timer: 0,
        fading: false,
        w: textWidth
    });
}

function createExplosion(x, y, color, count=10) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 1.0,
            color: color
        });
    }
}

function checkCollision(e) {
    const playerBox = { x: player.x, y: player.y, w: player.w, h: player.h };
    const enemyBox = { x: e.x - e.w/2, y: e.y - 15, w: e.w, h: 30 };

    return playerBox.x < enemyBox.x + enemyBox.w &&
           playerBox.x + playerBox.w > enemyBox.x &&
           playerBox.y < enemyBox.y + enemyBox.h &&
           playerBox.y + playerBox.h > enemyBox.y;
}


function update(dt) {
    if (!gameRunning) return;

    if (player.invincible) {
        player.invTimer -= dt;
        if (player.invTimer <= 0) player.invincible = false;
    }

    if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
    if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;

    stars.forEach(s => { s.y += s.speed; if(s.y > canvas.height) s.y = 0; });
    spawnTimer -= dt;
    if (spawnTimer < 0) { spawnEnemy(); spawnTimer = SPAWN_INTERVAL; }

    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 12;
        if (bullets[i].y < 0) bullets.splice(i, 1);
    }

    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];

        if (!e.fading) {
            e.y += e.speed;
            
            // Player Collision
            if (!player.invincible && checkCollision(e)) {
                lives--;
                livesEl.innerText = lives;
                createExplosion(player.x + player.w/2, player.y + player.h/2, '#ff4444', 30);
                playSound('player_hit');
                player.invincible = true;
                player.invTimer = 2000;
                enemies.splice(i, 1);
                combo = 0;
                comboEl.innerText = combo;

                if (lives <= 0) {
                    gameOver();
                    return;
                }
                continue;
            }

            if (e.stage >= 1) { 
                e.timer += dt;
                // If they float too long without being shot again, they fade (no penalty)
                if (e.timer > 4000) { e.fading = true; } 
            }
        } else {
            createExplosion(e.x, e.y, e.color, 1);
            enemies.splice(i, 1);
            continue;
        }

        // Bullet Collision
        for (let j = bullets.length - 1; j >= 0; j--) {
            let b = bullets[j];
            if (b.x > e.x - 40 && b.x < e.x + 40 && b.y > e.y - 20 && b.y < e.y + 10) {
                
                bullets.splice(j, 1); 
                e.timer = 0; 
                e.stage++; 

                if (e.stage === 1) { // 1st HIT: EN -> SP1 (Primary)
                    e.text = e.wordData.es[0];
                    e.color = '#00ff00'; 
                    playSound('hit_eng');
                    score += 10;
                } else if (e.stage === 2) { // 2nd HIT: SP1 -> SP2/SP3 (Random Synonym)
                    const synIdx = e.synonymPath[1];
                    e.text = e.wordData.es[synIdx] || e.wordData.es[0]; // Fallback
                    e.color = '#ffff00'; 
                    createExplosion(e.x, e.y, '#ffff00', 20);
                    playSound('hit_syn');
                    score += 50;
                    combo++;
                } else if (e.stage === 3) { // 3rd HIT: SP2/SP3 -> EN (Review)
                    e.text = e.wordData.en;
                    e.color = '#4f46e5'; 
                    createExplosion(e.x, e.y, '#4f46e5', 10);
                    playSound('hit_review');
                    score += 100;
                    combo++;
                } else if (e.stage === 4) { // 4th HIT: DESTROY
                    e.fading = true;
                    createExplosion(e.x, e.y, '#ffffff', 40);
                    playSound('hit_syn');
                    score += 150;
                    combo++;
                }
                
                scoreEl.innerText = score;
                comboEl.innerText = combo;
                break;
            }
        }

        if (e.y > canvas.height) {
            if (e.stage < 4) combo = 0; 
            comboEl.innerText = combo;
            enemies.splice(i, 1);
        }
    }

    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.life -= 0.04;
        if(p.life <= 0) particles.splice(i, 1);
    }
}

function draw() {
    if(!gameRunning) return;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Use clearRect for cleaner refresh

    stars.forEach(s => {
        ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.3})`;
        ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
    });

    // Player (Invincibility Flicker)
    if (!player.invincible || (Math.floor(player.invTimer / 100) % 2 === 0)) {
        ctx.fillStyle = player.color;
        ctx.shadowBlur = 10; ctx.shadowColor = player.color;
        ctx.beginPath();
        ctx.moveTo(player.x + player.w/2, player.y);
        ctx.lineTo(player.x + player.w, player.y + player.h);
        ctx.lineTo(player.x, player.y + player.h);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    // Bullets
    ctx.fillStyle = '#ff0055';
    ctx.shadowBlur = 5; ctx.shadowColor = '#ff0055';
    bullets.forEach(b => ctx.fillRect(b.x - 2, b.y, 4, 15));
    ctx.shadowBlur = 0;

    // Enemies
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    enemies.forEach(e => {
        ctx.font = e.stage >= 1 ? '20px "Press Start 2P"' : '16px "Press Start 2P"';
        ctx.fillStyle = e.color;
        
        if (e.stage >= 2) { ctx.shadowBlur = 10; ctx.shadowColor = (e.stage === 3) ? '#4f46e5' : '#ffff00'; }
        ctx.fillText(e.text, e.x, e.y);
        ctx.shadowBlur = 0;
        
        // Health Dots (Stages)
        for(let k=0; k<4; k++) {
            ctx.fillStyle = k < e.stage ? '#00ff00' : '#444'; 
            ctx.beginPath();
            ctx.arc(e.x - 22 + (k*15), e.y + 25, 3, 0, Math.PI*2);
            ctx.fill();
        }
    });

    // Particles
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fillRect(p.x, p.y, 3, 3);
        ctx.globalAlpha = 1;
    });

    requestAnimationFrame(() => {
        const now = performance.now();
        const delta = now - lastTime;
        lastTime = now;
        update(delta);
        draw();
    });
}


function gameOver() {
    gameRunning = false;
    clearInterval(musicInterval);
    
    const isNewHighScore = score > highScore;
    if (isNewHighScore) {
        highScore = score;
        localStorage.setItem('synonymHunterHighScore', highScore);
        highScoreEl.innerText = highScore;
    }

    document.getElementById('finalScore').innerText = score;
    document.getElementById('newHighScore').innerText = isNewHighScore ? 'YES!' : 'NO';
    gameOverScreen.style.display = 'flex';
}

function startGame() {
    if (gameRunning) return;

    resize();

    startScreen.style.display = 'none';
    gameOverScreen.style.display = 'none';
    gameRunning = true;
    
    score = 0; 
    combo = 0;
    lives = 5;
    enemies.length = 0; 
    bullets.length = 0; 
    particles.length = 0;
    player.invincible = false;
    
    scoreEl.innerText = '0';
    comboEl.innerText = '0';
    livesEl.innerText = '5';
    
    renderCategoryBar();
    loadHighScore(); 
    lastTime = performance.now();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    startMusic();
    draw();
}

// Input
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'Space' && gameRunning) {
        // Prevent default spacebar scrolling
        e.preventDefault();
        bullets.push({ x: player.x + player.w/2, y: player.y });
        playSound('shoot');
    }
});
window.addEventListener('keyup', e => keys[e.code] = false);

// Init
window.onload = () => {
    resize();
    renderCategoryBar();
};
</script>
</body>
</html>
