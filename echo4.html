<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LINGUA NEXUS | HUB</title>
    <link href="https://fonts.googleapis.com/css2?family=Syncopate:wght@700&family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    <script src="https://www.youtube.com/iframe_api"></script>
    <style>
        :root {
            --bg-deep: #050505;
            --neon-blue: #00f3ff;
            --neon-purple: #bd00ff;
            --card-bg: #111;
            --text-main: #ffffff;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            background-color: var(--bg-deep);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            margin: 0;
            height: 100vh;
            /* Importante: Permitir scroll en el body si el contenedor lo requiere */
            overflow: hidden; 
        }

        /* === 1. LIBRARY VIEW === */
        #library-view {
            width: 100%; 
            height: 100%;
            display: flex; 
            flex-direction: column;
            background: radial-gradient(circle at top, #1a1a1a, #000);
            position: relative;
            z-index: 10;
        }

        .hub-close-btn {
            position: absolute; top: 15px; right: 15px;
            width: 35px; height: 35px;
            background: #333; border: 1px solid #444; color: #ccc;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 14px; font-weight: bold; cursor: pointer; z-index: 50;
        }

        /* Contenedor con Scroll independiente */
        .scroll-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-top: 60px; /* Espacio para el bot√≥n de cierre */
            /* Scroll suave */
            -webkit-overflow-scrolling: touch;
        }

        .grid-container {
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); /* Ajustado para m√≥viles peque√±os */
            gap: 15px; 
            padding-bottom: 80px; /* Extra padding para que no se corte abajo */
        }

        .video-card {
            background: var(--card-bg); border-radius: 12px; overflow: hidden;
            cursor: pointer; border: 1px solid rgba(255,255,255,0.05);
            transition: transform 0.2s;
            position: relative; 
            transform: translateZ(0); 
            min-height: 160px; /* Altura m√≠nima para asegurar visibilidad */
            display: flex; flex-direction: column;
        }
        .video-card:active { transform: scale(0.95); }
        
        .thumb-wrapper { 
            position: relative; 
            width: 100%; 
            aspect-ratio: 16/9; /* Mantiene proporci√≥n de video */
            background: #000; 
            flex-shrink: 0;
        }

        .thumb-img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0.8; }
        
        .card-badge {
            position: absolute; bottom: 5px; right: 5px;
            background: rgba(0,0,0,0.8); color: var(--neon-blue);
            font-size: 10px; padding: 3px 6px; border-radius: 4px; font-weight: bold;
            border: 1px solid rgba(0, 243, 255, 0.3);
            z-index: 50; 
        }
        .card-info { padding: 12px; flex: 1; display: flex; flex-direction: column; justify-content: center; }
        .card-title { font-size: 13px; font-weight: 600; color: #eee; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; }
        .card-meta { font-size: 11px; color: #888; margin-top: 6px; }

        /* üî• DADO RANDOM SOLIDO Y VISIBLE üî• */
        .random-thumb {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #2a2a2a, #050505); 
            display: flex; align-items: center; justify-content: center;
            font-size: 36px;
            z-index: 2;
            color: var(--neon-blue);
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
        }

        /* === 2. STREAM VIEW (PLAYER) === */
        #stream-view {
            display: none; width: 100%; height: 100%;
            position: fixed; top: 0; left: 0;
            background: #000; z-index: 100;
        }

        #stream-container {
            height: 100%; overflow-y: scroll;
            scroll-snap-type: y mandatory; scroll-behavior: smooth;
        }

        .exit-btn {
            position: fixed; top: 20px; left: 20px; z-index: 5000;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
            color: white; width: 40px; height: 40px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; cursor: pointer;
        }

        /* === CAPAS === */
        .echo-card { 
            width: 100%; height: 100%; 
            scroll-snap-align: start; scroll-snap-stop: always; 
            position: relative; overflow: hidden; 
            background: #000;
        }

        .layer-video { 
            position: absolute; top: -15%; left: -15%; width: 130%; height: 130%; 
            pointer-events: none; z-index: 1; opacity: 0; transition: opacity 0.5s; 
        }
        .echo-card.playing .layer-video { opacity: 1; }
        .layer-video iframe { width: 100%; height: 100%; }

        .layer-interface {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none; 
            display: flex; flex-direction: column; justify-content: flex-end;
        }

        .click-zone { 
            position: absolute; top: 0; left: 0; width: 100%; height: 80%; 
            z-index: 11; pointer-events: auto; cursor: pointer; 
        }

        .center-icon { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            font-size: 80px; color: rgba(255,255,255,0.8); z-index: 12; 
            opacity: 0; transition: 0.2s; pointer-events: none; 
        }
        .paused-state .center-icon { opacity: 1; }

        /* HUD */
        .hud-wrapper {
            width: 100%; padding: 20px; padding-bottom: 80px;
            background: linear-gradient(to top, rgba(0,0,0,1) 0%, rgba(0,0,0,0) 100%);
            pointer-events: none; z-index: 15;
            transition: all 0.3s;
        }
        .main-word { font-family: 'Syncopate', sans-serif; font-size: 30px; color: #fff; text-transform: uppercase; text-shadow: 0 0 10px rgba(0,243,255,0.5); }
        .translation { font-size: 16px; color: var(--neon-purple); font-weight: 600; }
        .context-sentence { font-size: 14px; color: #ccc; font-style: italic; border-left: 3px solid var(--neon-blue); padding-left: 10px; margin-top: 5px; }
        
        .blind-active .main-word, 
        .blind-active .translation, 
        .blind-active .context-sentence { 
            color: transparent !important;
            text-shadow: 0 0 18px rgba(255,255,255,0.9) !important;
            filter: none !important; 
            user-select: none;
        }

        .controls-rail { 
            position: absolute; right: 15px; bottom: 150px; 
            z-index: 50; display: flex; flex-direction: column; gap: 20px; pointer-events: auto; 
        }
        .rail-btn { width: 45px; height: 45px; border-radius: 50%; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.3); color: white; display: flex; align-items: center; justify-content: center; font-size: 18px; cursor: pointer; }
        .rail-btn.active { background: var(--neon-blue); color: #000; box-shadow: 0 0 15px var(--neon-blue); }

        .loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1); border-top: 3px solid var(--neon-blue); border-radius: 50%; animation: spin 1s linear infinite; z-index: 5; }
        @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }
        .progress-bar-bottom { position: absolute; bottom: 0; left: 0; height: 4px; background: var(--neon-blue); z-index: 100; transition: width 0.1s linear; }

    </style>
</head>
<body>

    <div id="library-view">
        <button class="hub-close-btn" onclick="notifyParentClose()">‚úï</button>
        <div class="scroll-area">
            <div id="library-grid" class="grid-container">
                </div>
        </div>
    </div>

    <div id="stream-view">
        <button class="exit-btn" onclick="exitStream()">‚úï</button>
        <div id="stream-container"></div>
    </div>

<script>
        // === CAMBIO CRITICO: ESTRATEGIA SEGURA DE STORAGE ===
        // Esto evita que la app se rompa si el iframe bloquea el acceso al padre
        let storageSource = localStorage; // Por defecto usamos el local
        try {
            if (window.self !== window.top && window.parent && window.parent.localStorage) {
                // Intentamos acceder solo para ver si no explota
                const test = window.parent.localStorage.length; 
                storageSource = window.parent.localStorage;
                console.log("Conectado al Storage del Padre");
            }
        } catch (e) {
            console.warn("Acceso al Storage del padre bloqueado, usando local interno.");
        }
        
        const STORAGE_KEY = 'mdc_vocab_list';
        let allItems = [], groupedByVideo = {}, activeItems = [], players = {}, progressIntervals = {};
        let observer, blindMode = false;

        function notifyParentClose() { try { if(window.parent && window.parent.closeNexus) window.parent.closeNexus(); } catch(e) {} }

        function init() { loadData(); renderLibrary(); }

        function loadData() {
            try {
                // Usamos la fuente de almacenamiento segura definida arriba
                const raw = storageSource.getItem(STORAGE_KEY);
                const data = JSON.parse(raw || '[]');
                allItems = []; groupedByVideo = {};
                
                const flatten = (list) => {
                    list.forEach(item => {
                        if (item.isFolder && item.items) flatten(item.items);
                        else if (item.source && item.source.type === 'youtube') {
                            allItems.push(item);
                            const vId = item.source.videoId;
                            if (!groupedByVideo[vId]) groupedByVideo[vId] = { id: vId, title: item.source.title || "Video", count: 0, items: [] };
                            groupedByVideo[vId].items.push(item);
                            groupedByVideo[vId].count++;
                        }
                    });
                };
                flatten(data);
                console.log(`Cargados ${allItems.length} items.`);
            } catch (e) { 
                console.error("Error cargando datos", e); 
            }
        }

        function renderLibrary() {
            const grid = document.getElementById('library-grid');
            grid.innerHTML = '';

            // === 1. RANDOM MIX (Renderizado INCONDICIONAL) ===
            // Se renderiza PRIMERO y sin depender de si hay videos o no, para que siempre "se vea"
            const randomCard = document.createElement('div');
            randomCard.className = 'video-card';
            randomCard.onclick = () => startStream('RANDOM_MIX'); 
            randomCard.innerHTML = `
                <div class="thumb-wrapper">
                    <div class="random-thumb">üé≤</div>
                    <div class="card-badge">${allItems.length}</div>
                </div>
                <div class="card-info">
                    <div class="card-title" style="color:var(--neon-blue); font-size: 15px;">RANDOM MIX</div>
                    <div class="card-meta">Shuffle Mode</div>
                </div>
            `;
            grid.appendChild(randomCard);

            // === 2. VIDEOS ===
            Object.keys(groupedByVideo).forEach(vId => {
                const group = groupedByVideo[vId];
                const card = document.createElement('div');
                card.className = 'video-card';
                card.onclick = () => startStream(vId);
                card.innerHTML = `
                    <div class="thumb-wrapper">
                        <img src="https://img.youtube.com/vi/${vId}/mqdefault.jpg" class="thumb-img" onerror="this.style.display='none'">
                        <div class="card-badge">${group.count}</div>
                    </div>
                    <div class="card-info">
                        <div class="card-title">${group.title}</div>
                        <div class="card-meta">Video Set</div>
                    </div>
                `;
                grid.appendChild(card);
            });
            
            // Si no hay videos, a√±adir mensaje visual
            if(Object.keys(groupedByVideo).length === 0 && allItems.length === 0) {
                 const emptyMsg = document.createElement('div');
                 emptyMsg.style.gridColumn = "1 / -1";
                 emptyMsg.style.color = "#666";
                 emptyMsg.style.textAlign = "center";
                 emptyMsg.style.padding = "20px";
                 emptyMsg.innerText = "No data loaded within iframe.";
                 grid.appendChild(emptyMsg);
            }
        }

        function startStream(filterVideoId) {
            if (filterVideoId === 'RANDOM_MIX') {
                if(allItems.length === 0) return alert("No items to shuffle.");
                activeItems = [...allItems];
                activeItems.sort(() => Math.random() - 0.5);
            } else if (filterVideoId) {
                activeItems = [...groupedByVideo[filterVideoId].items];
                activeItems.sort((a, b) => parseFloat(a.source.timestamp) - parseFloat(b.source.timestamp));
            } else { return; }

            renderStreamCards();
            setupObserver();
            document.getElementById('library-view').style.display = 'none';
            document.getElementById('stream-view').style.display = 'block';
        }

        function exitStream() {
            Object.keys(players).forEach(idx => destroyVideo(idx));
            if(observer) observer.disconnect();
            document.getElementById('stream-view').style.display = 'none';
            document.getElementById('library-view').style.display = 'flex';
            // Recargar para refrescar estado
            loadData(); renderLibrary();
        }

        // ... El resto de la l√≥gica de reproducci√≥n se mantiene igual ...
        function renderStreamCards() {
            const container = document.getElementById('stream-container');
            container.innerHTML = '';
            activeItems.forEach((item, index) => {
                const card = document.createElement('div');
                card.className = 'echo-card';
                card.id = `card-${index}`;
                card.dataset.index = index;
                card.dataset.videoId = item.source.videoId;
                
                const baseStart = Math.max(0, parseFloat(item.source.timestamp) - 1.5);
                const baseEnd = parseFloat(item.source.timestamp) + 3.0;
                const currentStart = (item.customStart !== undefined) ? parseFloat(item.customStart) : baseStart;
                const currentEnd = (item.customEnd !== undefined) ? parseFloat(item.customEnd) : baseEnd;

                card.dataset.currentStart = currentStart; card.dataset.currentEnd = currentEnd;

                card.innerHTML = `
                    <div class="layer-video" id="video-wrapper-${index}"></div>
                    <div class="layer-interface">
                        <div class="click-zone" onclick="togglePlayPause(${index})"></div>
                        <div class="center-icon">‚ñ∂</div>
                        <div class="loader"></div>
                        <div class="hud-wrapper">
                            <div class="main-word">${item.eng}</div>
                            <div class="translation">${item.esp || ''}</div>
                            <div class="context-sentence">"${item.source.context || ''}"</div>
                        </div>
                        <div class="controls-rail">
                            <button class="rail-btn" onclick="toggleBlindMode(this)">üëÅÔ∏è</button>
                            <button class="rail-btn" onclick="replayCard(${index})">‚Ü∫</button>
                        </div>
                        <div class="progress-bar-bottom" id="progress-${index}" style="width:0%"></div>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        function setupObserver() {
            const options = { root: document.getElementById('stream-container'), threshold: 0.7 };
            observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const idx = entry.target.dataset.index;
                    if (entry.isIntersecting) loadAndPlayVideo(idx);
                    else destroyVideo(idx);
                });
            }, options);
            document.querySelectorAll('.echo-card').forEach(card => observer.observe(card));
        }

        function loadAndPlayVideo(index) {
            const card = document.getElementById(`card-${index}`);
            if(!card || players[index]) return;
            const videoId = card.dataset.videoId;
            const start = parseFloat(card.dataset.currentStart);
            const tempDiv = document.createElement('div'); tempDiv.id = `yt-player-${index}`;
            document.getElementById(`video-wrapper-${index}`).appendChild(tempDiv);

            players[index] = new YT.Player(`yt-player-${index}`, {
                height: '100%', width: '100%', videoId: videoId,
                playerVars: { 'autoplay': 1, 'controls': 0, 'rel': 0, 'showinfo': 0, 'modestbranding': 1, 'playsinline': 1, 'iv_load_policy': 3, 'start': Math.floor(start) },
                events: {
                    'onReady': (event) => {
                        event.target.mute(); event.target.seekTo(start, true); event.target.playVideo();
                        setTimeout(() => { event.target.unMute(); event.target.setVolume(100); }, 400);
                        card.classList.add('playing'); card.querySelector('.loader').style.display = 'none';
                        startProgressTracking(index);
                    },
                    'onStateChange': (event) => { if (event.data === YT.PlayerState.ENDED) { event.target.seekTo(parseFloat(card.dataset.currentStart), true); event.target.playVideo(); } }
                }
            });
        }

        function startProgressTracking(index) {
            if(progressIntervals[index]) clearInterval(progressIntervals[index]);
            progressIntervals[index] = setInterval(() => {
                const player = players[index];
                if(!player || !player.getCurrentTime) return;
                const c = document.getElementById(`card-${index}`);
                const cs = parseFloat(c.dataset.currentStart), ce = parseFloat(c.dataset.currentEnd);
                const ct = player.getCurrentTime();
                if(ct >= ce || ct < cs - 0.5) player.seekTo(cs, true);
                const p = ((ct - cs) / (ce - cs)) * 100;
                const bar = document.getElementById(`progress-${index}`);
                if(bar) bar.style.width = `${Math.max(0, Math.min(100, p))}%`;
            }, 100);
        }

        function togglePlayPause(index) {
            const p = players[index];
            const c = document.getElementById(`card-${index}`);
            if (!p || typeof p.getPlayerState !== 'function') return;
            if (p.getPlayerState() === YT.PlayerState.PLAYING) { p.pauseVideo(); c.classList.add('paused-state'); } 
            else { p.playVideo(); c.classList.remove('paused-state'); }
        }

        function destroyVideo(index) {
            if(progressIntervals[index]) clearInterval(progressIntervals[index]);
            if (players[index]) {
                try { players[index].destroy(); } catch(e){}
                delete players[index];
                const card = document.getElementById(`card-${index}`);
                if(card) {
                    card.classList.remove('playing', 'paused-state');
                    card.querySelector('.loader').style.display = 'block';
                    document.getElementById(`video-wrapper-${index}`).innerHTML = '';
                    const bar = document.getElementById(`progress-${index}`); if(bar) bar.style.width = '0%';
                }
            }
        }

        window.toggleBlindMode = (btn) => { 
            blindMode = !blindMode; 
            btn.classList.toggle('active', blindMode); 
            document.querySelectorAll('.hud-wrapper').forEach(h => {
                if(blindMode) h.classList.add('blind-active'); 
                else h.classList.remove('blind-active');
            });
        };
        
        window.replayCard = (index) => { if(players[index]) { const c = document.getElementById(`card-${index}`); players[index].seekTo(parseFloat(c.dataset.currentStart), true); players[index].playVideo(); c.classList.remove('paused-state'); } };

        // Retrasamos init un instante para asegurar carga del DOM
        setTimeout(init, 50);
</script>
</body>
</html>
