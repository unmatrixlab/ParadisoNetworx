<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LINGUA NEXUS | HUB</title>
    <link href="https://fonts.googleapis.com/css2?family=Syncopate:wght@700&family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    <script src="https://www.youtube.com/iframe_api"></script>
    <style>
        :root {
            --bg-deep: #050505;
            --neon-blue: #00f3ff;
            --neon-purple: #bd00ff;
            --card-bg: #111;
            --text-main: #ffffff;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            background-color: var(--bg-deep);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        /* === 1. LIBRARY VIEW (DASHBOARD) === */
        #library-view {
            width: 100%; height: 100%;
            padding: 20px;
            overflow-y: auto;
            display: flex; flex-direction: column;
            background: radial-gradient(circle at top, #1a1a1a, #000);
            position: relative;
        }

        .hub-close-btn {
            position: absolute; top: 15px; right: 15px;
            width: 35px; height: 35px;
            background: #333; border: 1px solid #444; color: #ccc;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 14px; font-weight: bold; cursor: pointer; z-index: 50;
            transition: all 0.2s;
        }
        .hub-close-btn:hover { background: #444; color: white; border-color: #666; }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 20px;
            padding-bottom: 50px;
            padding-top: 40px;
        }

        .video-card {
            background: var(--card-bg); border-radius: 12px; overflow: hidden;
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
            border: 1px solid rgba(255,255,255,0.05); position: relative;
        }
        .video-card:active { transform: scale(0.98); }
        
        .thumb-wrapper {
            position: relative; padding-bottom: 56.25%; background: #000;
        }
        .thumb-img {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0.8;
        }
        .card-badge {
            position: absolute; bottom: 5px; right: 5px;
            background: rgba(0,0,0,0.8); color: var(--neon-blue);
            font-size: 10px; padding: 3px 6px; border-radius: 4px; font-weight: bold;
            border: 1px solid rgba(0, 243, 255, 0.3);
        }

        .card-info { padding: 12px; }
        .card-title {
            font-size: 13px; font-weight: 600; line-height: 1.4; color: #eee;
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
        }
        .card-meta { font-size: 11px; color: #888; margin-top: 6px; }

        /* === 2. STREAM VIEW (PLAYER) === */
        #stream-view {
            display: none; width: 100%; height: 100%;
            position: fixed; top: 0; left: 0;
            background: #000; z-index: 100;
        }

        #stream-container {
            height: 100%; overflow-y: scroll;
            scroll-snap-type: y mandatory; scroll-behavior: smooth;
        }

        .exit-btn {
            position: fixed; top: 20px; left: 20px; z-index: 200;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
            color: white; width: 40px; height: 40px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; cursor: pointer;
        }

        /* === PLAYER STYLES === */
        .echo-card { width: 100%; height: 100%; scroll-snap-align: start; scroll-snap-stop: always; position: relative; overflow: hidden; }
        .video-layer { position: absolute; top: -15%; left: -15%; width: 130%; height: 130%; pointer-events: none; opacity: 0; transition: opacity 0.5s; }
        .echo-card.playing .video-layer { opacity: 1; }
        .video-layer iframe { width: 100%; height: 100%; }
        .click-zone { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; cursor: pointer; }
        .center-icon { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.5); font-size: 80px; color: rgba(255,255,255,0.8); opacity: 0; pointer-events: none; transition: 0.2s; z-index: 60; }
        .paused-state .center-icon { opacity: 1; transform: scale(1); }
        
        .hud-layer { 
            position: absolute; bottom: 0; left: 0; width: 100%; 
            padding: 20px 20px 140px 20px; /* M√°s padding bottom para dejar espacio al timeline */
            z-index: 10; 
            background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0) 100%); 
            pointer-events: none; 
        }
        
        .main-word { font-family: 'Syncopate', sans-serif; font-size: 32px; color: #fff; text-transform: uppercase; text-shadow: 0 0 15px rgba(0, 243, 255, 0.4); margin-bottom: 5px; }
        .translation { font-size: 16px; color: var(--neon-purple); font-weight: 600; margin-bottom: 10px; }
        .context-sentence { font-size: 14px; color: #ccc; font-style: italic; border-left: 3px solid var(--neon-blue); padding-left: 10px; }
        .blind-active .main-word, .blind-active .translation, .blind-active .context-sentence { filter: blur(12px); opacity: 0; }
        
        .progress-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 4px; background: rgba(255,255,255,0.1); z-index: 20; }
        .progress-bar { height: 100%; width: 0%; background: var(--neon-blue); transition: width 0.1s linear; }
        
        .controls-rail { position: absolute; right: 15px; bottom: 120px; z-index: 30; display: flex; flex-direction: column; gap: 20px; pointer-events: auto; }
        .rail-btn { width: 50px; height: 50px; border-radius: 50%; background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); color: white; display: flex; align-items: center; justify-content: center; font-size: 20px; cursor: pointer; }
        
        .loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1); border-top: 3px solid var(--neon-blue); border-radius: 50%; animation: spin 1s linear infinite; z-index: 5; }
        @keyframes spin { 0% { transform: translate(-50%, -50%) rotate(0deg); } 100% { transform: translate(-50%, -50%) rotate(360deg); } }
        .scanlines { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%); background-size: 100% 4px; box-shadow: inset 0 0 100px rgba(0,0,0,0.7); }

        /* === NUEVA LINEA DE TIEMPO (TRIMMER) === */
        .trim-wrapper {
            position: absolute;
            bottom: 30px; /* Encima de la barra de progreso inferior */
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            height: 40px;
            z-index: 40;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .trim-info {
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--neon-blue);
            margin-bottom: 8px;
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.5);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .trim-wrapper.interacting .trim-info { opacity: 1; }

        .trim-track {
            position: relative;
            width: 100%;
            height: 4px;
            background: #444; /* Gris */
            border-radius: 2px;
        }

        .trim-fill {
            position: absolute;
            top: 0;
            height: 100%;
            background: var(--neon-blue); /* Azul entre puntos */
            opacity: 0.7;
        }

        .trim-handle {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            background: var(--neon-blue);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(0, 243, 255, 0.6);
            touch-action: none; /* Crucial para m√≥viles */
        }
        .trim-handle::after {
            content: ''; position: absolute; top: -10px; left: -10px; right: -10px; bottom: -10px; /* √Årea de toque m√°s grande */
        }

    </style>
</head>
<body>

    <div id="library-view">
        <button class="hub-close-btn" onclick="notifyParentClose()">‚úï</button>
        <div id="library-grid" class="grid-container"></div>
    </div>

    <div id="stream-view">
        <div class="scanlines"></div>
        <button class="exit-btn" onclick="exitStream()">‚úï</button>
        <div id="stream-container"></div>
    </div>

  <script>
        const STORAGE_KEY = 'mdc_vocab_list';
        let allItems = [];
        let groupedByVideo = {};
        
        let activeItems = [];
        let players = {}; 
        let progressIntervals = {};
        let observer;
        let blindMode = false;

        // --- 0. COMUNICACI√ìN PADRE ---
        function notifyParentClose() {
            try {
                if(window.parent && window.parent.closeNexus) {
                    window.parent.closeNexus();
                }
            } catch(e) { console.error(e); }
        }

        // --- 1. DATA ---
        function init() { loadAndOrganizeData(); renderLibrary(); }

        function loadAndOrganizeData() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                const data = JSON.parse(raw || '[]');
                allItems = []; groupedByVideo = {};
                
                const flatten = (list) => {
                    list.forEach(item => {
                        if (item.isFolder && item.items) flatten(item.items);
                        else if (item.source && item.source.type === 'youtube') {
                            allItems.push(item);
                            const vId = item.source.videoId;
                            if (!groupedByVideo[vId]) {
                                groupedByVideo[vId] = { id: vId, title: item.source.title || "Unknown", count: 0, items: [] };
                            }
                            groupedByVideo[vId].items.push(item);
                            groupedByVideo[vId].count++;
                        }
                    });
                };
                flatten(data);
            } catch (e) { allItems = []; }
        }

        function renderLibrary() {
            const grid = document.getElementById('library-grid');
            grid.innerHTML = '';
            const videoIds = Object.keys(groupedByVideo);
            if (videoIds.length === 0) { grid.innerHTML = `<div style="text-align:center; color:#666; grid-column:1/-1;">NO DATA FOUND</div>`; return; }
            videoIds.forEach(vId => {
                const group = groupedByVideo[vId];
                const card = document.createElement('div');
                card.className = 'video-card';
                card.onclick = () => startStream(vId);
                const thumbUrl = `https://img.youtube.com/vi/${vId}/mqdefault.jpg`;
                card.innerHTML = `
                    <div class="thumb-wrapper"><img src="${thumbUrl}" class="thumb-img"><div class="card-badge">${group.count} words</div></div>
                    <div class="card-info"><div class="card-title">${group.title}</div><div class="card-meta">TAP TO STUDY</div></div>
                `;
                grid.appendChild(card);
            });
        }

        // --- 3. STREAM & PLAYER ---
        function startStream(filterVideoId) {
            if (filterVideoId) {
                activeItems = [...groupedByVideo[filterVideoId].items];
                activeItems.sort((a, b) => parseFloat(a.source.timestamp) - parseFloat(b.source.timestamp));
            } else {
                activeItems = [...allItems];
                activeItems.sort(() => Math.random() - 0.5);
            }
            if(activeItems.length === 0) return alert("No items.");
            renderStreamCards();
            setupObserver();
            document.getElementById('library-view').style.display = 'none';
            document.getElementById('stream-view').style.display = 'block';
        }

        function exitStream() {
            Object.keys(players).forEach(idx => destroyVideo(idx));
            if(observer) observer.disconnect();
            document.getElementById('stream-view').style.display = 'none';
            document.getElementById('library-view').style.display = 'flex';
        }

        function renderStreamCards() {
            const container = document.getElementById('stream-container');
            container.innerHTML = '';
            activeItems.forEach((item, index) => {
                const card = document.createElement('div');
                card.className = 'echo-card';
                card.id = `card-${index}`;
                card.dataset.index = index;
                card.dataset.videoId = item.source.videoId;
                
                // Tiempos Base (Referencia inmutable)
                const baseStart = Math.max(0, parseFloat(item.source.timestamp) - 1.5);
                const baseEnd = parseFloat(item.source.timestamp) + 3.0;
                
                // Tiempos Actuales (Usamos los guardados si existen, si no, los base)
                const currentStart = (item.customStart !== undefined) ? parseFloat(item.customStart) : baseStart;
                const currentEnd = (item.customEnd !== undefined) ? parseFloat(item.customEnd) : baseEnd;

                card.dataset.baseStart = baseStart;
                card.dataset.baseEnd = baseEnd;
                card.dataset.currentStart = currentStart;
                card.dataset.currentEnd = currentEnd;

                card.innerHTML = `
                    <div class="loader"></div>
                    <div class="video-layer" id="video-wrapper-${index}"></div>
                    <div class="click-zone" onclick="togglePlayPause(${index})"></div>
                    <div class="center-icon">‚ñ∂</div>
                    <div class="hud-layer">
                        <div class="main-word">${item.eng}</div>
                        <div class="translation">${item.esp || '...'}</div>
                        <div class="context-sentence">"${item.source.context || '...'}"</div>
                    </div>
                    
                    <div class="trim-wrapper" id="trim-wrapper-${index}">
                        <div class="trim-info" id="trim-info-${index}">Adjust Trim</div>
                        <div class="trim-track" id="trim-track-${index}">
                            <div class="trim-fill" id="trim-fill-${index}" style="left: 33%; width: 33%;"></div>
                            <div class="trim-handle" id="handle-start-${index}" style="left: 33%"></div>
                            <div class="trim-handle" id="handle-end-${index}" style="left: 66%"></div>
                        </div>
                    </div>

                    <div class="controls-rail">
                        <button class="rail-btn" onclick="toggleBlindMode(this)">üëÅÔ∏è</button>
                        <button class="rail-btn" onclick="replayCard(${index})">‚Ü∫</button>
                    </div>
                    <div class="progress-container"><div class="progress-bar" id="progress-${index}"></div></div>
                `;
                container.appendChild(card);
                
                // Inicializar el slider para esta tarjeta
                requestAnimationFrame(() => initTrimControls(index));
            });
        }

        // --- L√ìGICA DEL TRIMMER (CON GUARDADO) ---
        function initTrimControls(index) {
            const wrapper = document.getElementById(`trim-wrapper-${index}`);
            const track = document.getElementById(`trim-track-${index}`);
            const fill = document.getElementById(`trim-fill-${index}`);
            const handleStart = document.getElementById(`handle-start-${index}`);
            const handleEnd = document.getElementById(`handle-end-${index}`);
            const info = document.getElementById(`trim-info-${index}`);
            const card = document.getElementById(`card-${index}`);

            // Factor: 1% de movimiento = 0.05 segundos
            const TIME_SENSITIVITY = 0.05; 

            // Recuperar posiciones visuales basadas en los tiempos guardados
            const baseS = parseFloat(card.dataset.baseStart);
            const baseE = parseFloat(card.dataset.baseEnd);
            const currS = parseFloat(card.dataset.currentStart);
            const currE = parseFloat(card.dataset.currentEnd);

            // F√≥rmula inversa: (TiempoActual - TiempoBase) / Sensibilidad + Posici√≥nDefecto
            let startPct = 33 + ((currS - baseS) / TIME_SENSITIVITY);
            let endPct = 66 + ((currE - baseE) / TIME_SENSITIVITY);

            // Aplicar posiciones iniciales
            handleStart.style.left = startPct + '%';
            handleEnd.style.left = endPct + '%';
            fill.style.left = startPct + '%';
            fill.style.width = (endPct - startPct) + '%';

            const updateValues = () => {
                const startOffset = (startPct - 33) * TIME_SENSITIVITY;
                const endOffset = (endPct - 66) * TIME_SENSITIVITY;

                const newStart = Math.max(0, baseS + startOffset);
                const newEnd = Math.max(newStart + 0.5, baseE + endOffset); 

                card.dataset.currentStart = newStart.toFixed(2);
                card.dataset.currentEnd = newEnd.toFixed(2);

                info.innerText = `Start: ${startOffset > 0 ? '+' : ''}${startOffset.toFixed(1)}s | End: ${endOffset > 0 ? '+' : ''}${endOffset.toFixed(1)}s`;
                
                fill.style.left = startPct + '%';
                fill.style.width = (endPct - startPct) + '%';
            };

            // üî• NUEVA FUNCI√ìN DE GUARDADO üî•
            const saveTrimSettings = () => {
                const item = activeItems[index];
                const newS = parseFloat(card.dataset.currentStart);
                const newE = parseFloat(card.dataset.currentEnd);

                // 1. Actualizar objeto en memoria activa
                item.customStart = newS;
                item.customEnd = newE;

                // 2. Actualizar persistente en LocalStorage
                try {
                    const fullData = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
                    
                    // Funci√≥n recursiva para encontrar y actualizar el √≠tem
                    const updateRecursive = (list) => {
                        for (let i of list) {
                            if (i.id === item.id) {
                                i.customStart = newS;
                                i.customEnd = newE;
                                return true; // Encontrado y actualizado
                            }
                            if (i.isFolder && i.items) {
                                if (updateRecursive(i.items)) return true;
                            }
                        }
                        return false;
                    };

                    updateRecursive(fullData);
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(fullData));
                    console.log("Trim saved successfully");
                } catch(e) { console.error("Save failed", e); }
            };

            const onDrag = (e, isStart) => {
                e.preventDefault();
                wrapper.classList.add('interacting');
                
                const rect = track.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                let newPct = ((clientX - rect.left) / rect.width) * 100;
                newPct = Math.max(0, Math.min(100, newPct));

                if (isStart) {
                    if (newPct >= endPct - 5) newPct = endPct - 5; 
                    startPct = newPct;
                    handleStart.style.left = startPct + '%';
                } else {
                    if (newPct <= startPct + 5) newPct = startPct + 5;
                    endPct = newPct;
                    handleEnd.style.left = endPct + '%';
                }
                updateValues();
            };

            const stopDrag = () => { 
                wrapper.classList.remove('interacting');
                saveTrimSettings(); // üî• Guardamos al soltar
            };

            // Event Listeners
            const addDragListeners = (el, isStart) => {
                el.addEventListener('mousedown', (e) => {
                    const move = (ev) => onDrag(ev, isStart);
                    const up = () => { document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); stopDrag(); };
                    document.addEventListener('mousemove', move); document.addEventListener('mouseup', up);
                });
                el.addEventListener('touchstart', (e) => {
                    const move = (ev) => onDrag(ev, isStart);
                    const up = () => { document.removeEventListener('touchmove', move); document.removeEventListener('touchend', up); stopDrag(); };
                    document.addEventListener('touchmove', move); document.addEventListener('touchend', up);
                });
            };

            addDragListeners(handleStart, true);
            addDragListeners(handleEnd, false);
        }

        // --- OBSERVER & PLAYBACK ---
        function setupObserver() {
            const options = { root: document.getElementById('stream-container'), threshold: 0.7 };
            observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const idx = entry.target.dataset.index;
                    if (entry.isIntersecting) loadAndPlayVideo(idx);
                    else destroyVideo(idx);
                });
            }, options);
            document.querySelectorAll('.echo-card').forEach(card => observer.observe(card));
        }

        function loadAndPlayVideo(index) {
            const card = document.getElementById(`card-${index}`);
            if(!card || players[index]) return;

            const videoId = card.dataset.videoId;
            // USAR dataset.currentStart en vez de dataset.start est√°tico
            const start = parseFloat(card.dataset.currentStart || card.dataset.baseStart);
            
            const tempDiv = document.createElement('div');
            tempDiv.id = `yt-player-${index}`;
            document.getElementById(`video-wrapper-${index}`).innerHTML = '';
            document.getElementById(`video-wrapper-${index}`).appendChild(tempDiv);

            players[index] = new YT.Player(`yt-player-${index}`, {
                height: '100%', width: '100%', videoId: videoId,
                playerVars: { 'autoplay': 1, 'controls': 0, 'rel': 0, 'showinfo': 0, 'modestbranding': 1, 'playsinline': 1, 'iv_load_policy': 3, 'start': Math.floor(start) },
                events: {
                    'onReady': (event) => {
                        event.target.mute();
                        event.target.seekTo(start, true);
                        event.target.playVideo();
                        setTimeout(() => { event.target.unMute(); event.target.setVolume(100); }, 400);
                        card.querySelector('.loader').style.display = 'none';
                        card.classList.add('playing');
                        startProgressTracking(index);
                    },
                    'onStateChange': (event) => {
                        if (event.data === YT.PlayerState.ENDED) {
                            const s = parseFloat(card.dataset.currentStart);
                            event.target.seekTo(s, true);
                            event.target.playVideo();
                        }
                    }
                }
            });
        }

        function startProgressTracking(index) {
            if(progressIntervals[index]) clearInterval(progressIntervals[index]);
            const progressBar = document.getElementById(`progress-${index}`);
            const card = document.getElementById(`card-${index}`);
            
            progressIntervals[index] = setInterval(() => {
                const player = players[index];
                if(!player || !player.getCurrentTime) return;
                
                // LEER TIEMPOS DIN√ÅMICOS
                const currentStart = parseFloat(card.dataset.currentStart);
                const currentEnd = parseFloat(card.dataset.currentEnd);
                const duration = currentEnd - currentStart;
                
                const currentTime = player.getCurrentTime();
                
                // L√ìGICA DE LOOP
                if(currentTime >= currentEnd) {
                    player.seekTo(currentStart, true);
                } 
                else if (currentTime < currentStart - 0.5) { 
                    player.seekTo(currentStart, true);
                }

                const percent = ((currentTime - currentStart) / duration) * 100;
                if(progressBar) progressBar.style.width = `${Math.max(0, Math.min(100, percent))}%`;
            }, 100);
        }

        function togglePlayPause(index) {
            const player = players[index];
            const card = document.getElementById(`card-${index}`);
            if (!player || typeof player.getPlayerState !== 'function') return;
            const state = player.getPlayerState();
            if (state === YT.PlayerState.PLAYING) { player.pauseVideo(); card.classList.add('paused-state'); } 
            else { player.playVideo(); card.classList.remove('paused-state'); }
        }

        function destroyVideo(index) {
            if(progressIntervals[index]) clearInterval(progressIntervals[index]);
            if (players[index]) {
                try { players[index].destroy(); } catch(e){}
                delete players[index];
                const card = document.getElementById(`card-${index}`);
                if(card) {
                    card.classList.remove('playing', 'paused-state');
                    card.querySelector('.loader').style.display = 'block';
                    document.getElementById(`video-wrapper-${index}`).innerHTML = '';
                    const bar = document.getElementById(`progress-${index}`);
                    if(bar) bar.style.width = '0%';
                }
            }
        }

        // --- UTILS ---
        window.toggleBlindMode = function(btn) {
            blindMode = !blindMode;
            btn.classList.toggle('active', blindMode);
            document.querySelectorAll('.echo-card .hud-layer').forEach(hud => {
                if(blindMode) hud.classList.add('blind-active'); else hud.classList.remove('blind-active');
            });
        };
        window.replayCard = function(index) {
            if(players[index]) {
                const card = document.getElementById(`card-${index}`);
                const s = parseFloat(card.dataset.currentStart);
                players[index].seekTo(s, true);
                players[index].playVideo();
                card.classList.remove('paused-state');
            }
        };

        init();
    </script>
</body>
</html>
