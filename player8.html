<!doctype html>
<html lang="en"> 
<head>
    <meta charset="utf-8" />    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <title>MDC Studio Player (Dark Theme)</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* =========================================
           THEME V16 (Dark Aesthetic)
           ========================================= */
        :root { 
            --primary: #6366f1; 
            --primary-hover: #4f46e5; 
            --bg-body: #111827;       /* Fondo m√°s oscuro */
            --bg-panel: #1f2937;      /* Paneles/Tarjetas */
            --bg-input: #111827;      /* Fondo inputs */
            --border: #374151;        /* Bordes sutiles */
            --text-main: #f3f4f6;     /* Texto blanco suave */
            --text-sec: #9ca3af;      /* Texto gris */
            --saved-word: #f472b6;    /* Rosa ne√≥n suave */
            --danger: #ef4444;
            --success: #10b981;
            --radius: 12px; 
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body { 
            margin: 0; 
            font-family: 'Inter', sans-serif; 
            background: var(--bg-body); 
            color: var(--text-main); 
            height: 100vh; 
            display: flex; 
            flex-direction: column; 
            overflow: hidden; 
        }
        
        #mdc-header { display: none !important; }
        
        /* === SETUP SCREEN (Dark Mode) === */
        #setup-screen { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: var(--bg-body); 
            z-index: 2000; 
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start; 
            padding: 40px 20px; overflow-y: auto; 
        }
        
        .setup-container { 
            width: 100%; max-width: 900px; 
            display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-top: 20px; 
        }
        @media (max-width: 800px) { .setup-container { grid-template-columns: 1fr; } }
        
        .setup-card { 
            background: var(--bg-panel); /* Panel oscuro */
            padding: 30px; 
            border-radius: 16px; 
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3); 
            border: 1px solid var(--border); 
            height: fit-content; position: relative; min-width: 0; 
        }
        
        .setup-title { 
            font-size: 20px; font-weight: 800; color: var(--text-main); 
            margin-bottom: 20px; display: flex; align-items: center; gap: 10px; 
        }
        
        .input-group { margin-bottom: 15px; text-align: left; }
        .input-label { 
            display: block; font-size: 12px; font-weight: 700; 
            color: var(--primary); /* Acento */
            margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; 
        }
        
        .text-input { 
            width: 100%; padding: 12px; 
            background: var(--bg-input); 
            color: white; 
            border: 1px solid var(--border); 
            border-radius: 8px; font-size: 14px; font-family: monospace; transition: 0.2s; 
        }
        .text-input:focus { border-color: var(--primary); outline: none; box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2); }
        select.text-input { font-family: 'Inter', sans-serif; cursor: pointer; }

        .file-upload-btn { 
            display: flex; align-items: center; justify-content: center; width: 100%; padding: 12px; 
            border: 1px dashed var(--border); border-radius: 8px; 
            color: var(--text-sec); font-weight: 600; cursor: pointer; position: relative; font-size: 14px; 
            transition: 0.2s; background: rgba(255,255,255,0.02); 
        }
        .file-upload-btn:hover { border-color: var(--primary); color: var(--primary); background: rgba(99, 102, 241, 0.1); }
        .file-upload-btn.loaded { border-color: var(--success); color: var(--success); background: rgba(16, 185, 129, 0.1); border-style: solid; }
        
        .start-btn { 
            background: linear-gradient(135deg, var(--primary), #8b5cf6); 
            color: white; border: none; width: 100%; padding: 16px; border-radius: 12px; 
            font-size: 16px; font-weight: 800; cursor: pointer; margin-top: 15px; transition: 0.2s; 
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3); text-transform: uppercase; letter-spacing: 1px;
        }
        .start-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4); }

        .backup-btn { 
            position: relative; flex: 1; padding: 10px; border-radius: 8px; 
            border: 1px solid var(--border); background: var(--bg-input); 
            color: var(--text-sec); font-weight: 600; cursor: pointer; font-size: 13px; 
            display: flex; align-items: center; justify-content: center; gap: 5px; overflow: hidden; 
        }
        .backup-btn:hover { background: var(--bg-panel); border-color: var(--primary); color: white; }
        input[type="file"] { position: absolute; width: 100%; height: 100%; opacity: 0; cursor: pointer; top:0; left:0; }
        .backup-actions { display: flex; gap: 10px; margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border); }

        /* === FILTERS === */
        .cat-filter-container { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 10px; margin-bottom: 15px; border-bottom: 1px solid var(--border); scrollbar-width: none; }
        .cat-filter-container::-webkit-scrollbar { display: none; }
        .cat-btn { 
            padding: 6px 12px; border-radius: 20px; border: 1px solid var(--border); 
            background: var(--bg-input); color: var(--text-sec); 
            font-size: 12px; font-weight: 600; cursor: pointer; white-space: nowrap; transition: all 0.2s; 
        }
        .cat-btn:hover { border-color: var(--primary); color: white; }
        .cat-btn.active { background: var(--primary); color: white; border-color: var(--primary); }
        
        .history-list { display: flex; flex-direction: column; gap: 10px; max-height: 300px; overflow-y: auto; }
        .history-item { 
            display: flex; align-items: center; padding: 12px; 
            background: var(--bg-input); /* Fondo oscuro items */
            border-radius: 10px; cursor: pointer; transition: 0.2s; border: 1px solid transparent; 
        }
        .history-item:hover { background: #2d3748; border-color: var(--primary); }
        .h-thumb { width: 50px; height: 38px; border-radius: 4px; background: #000; margin-right: 12px; background-size: cover; background-position: center; flex-shrink: 0; border: 1px solid var(--border); }
        .h-info { flex: 1; min-width: 0; }
        .h-title { font-size: 14px; font-weight: 700; color: var(--text-main); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .h-date { font-size: 11px; color: var(--text-sec); display: flex; align-items: center; gap: 6px; }
        .h-tag { background: rgba(99, 102, 241, 0.2); color: #a5b4fc; padding: 2px 6px; border-radius: 4px; font-size: 9px; font-weight: 700; text-transform: uppercase; }
        .h-btn-del { padding: 5px 8px; font-size: 12px; color: var(--danger); background: transparent; border: none; cursor: pointer; opacity: 0.5; }
        .h-btn-del:hover { opacity: 1; background: rgba(239, 68, 68, 0.1); border-radius: 4px; }
        
        .h-btn-copy { padding: 5px 8px; font-size: 14px; color: var(--primary); background: transparent; border: none; cursor: pointer; opacity: 0.5; margin-right: 2px; }
        .h-btn-copy:hover { opacity: 1; background: rgba(99, 102, 241, 0.2); border-radius: 4px; }

        .empty-history { text-align: center; color: var(--text-sec); font-size: 14px; padding: 20px; font-style: italic; }
        .library-section { margin-bottom: 25px; border-bottom: 1px solid var(--border); padding-bottom: 20px; }
        .library-label { display: block; font-size: 12px; font-weight: 700; color: var(--primary); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }

        /* === PLAYER UI === */
        #player-ui { display: none; width: 100%; height: 100%; position: fixed; top: 0; left: 0; background: var(--bg-body); z-index: 100; }
        .page-max-width { max-width: 1000px; margin: 0 auto; width: 100%; height: 100%; display: flex; flex-direction: column; position: relative; }
        .video-wrapper { position: relative; width: 100%; background: #000; z-index: 500; box-shadow: var(--shadow); flex-shrink: 0; border-bottom: 1px solid var(--border); }
        .video-inner { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; background: #000; }
        .video-inner iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0; z-index: 1; }
        #video-cover { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; background-position: center; background-repeat: no-repeat; z-index: 10; cursor: pointer; display: flex; align-items: center; justify-content: center; background-color: #000; }
        #video-cover::after { content: '‚ñ∂'; font-size: 60px; color: white; filter: drop-shadow(0 2px 10px rgba(0,0,0,0.7)); opacity: 0.9; transition: 0.2s; }
        #video-cover:hover::after { transform: scale(1.1); opacity: 1; color: var(--primary); }

        .dialogue-container { padding: 20px 15px 140px 15px; max-width: 600px; margin: 0 auto; width: 100%; flex: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; min-height: 0; }
        .dialogue-container::-webkit-scrollbar { width: 6px; }
        .dialogue-container::-webkit-scrollbar-track { background: transparent; }
        .dialogue-container::-webkit-scrollbar-thumb { background: var(--border); border-radius: 10px; }
        .dialogue-container::-webkit-scrollbar-thumb:hover { background: var(--text-sec); }

        .line { 
            background: var(--bg-panel); /* Tarjeta oscura */
            border-radius: var(--radius); 
            padding: 15px; 
            margin-bottom: 16px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); 
            border: 1px solid var(--border);
            border-left: 4px solid rgba(255, 255, 255, 0.15);/*border-left: 4px solid transparent; */
            transition: all 0.2s ease; 
        }
        /* Estilo para la l√≠nea activa (Focus) */
        .line.active { 
            border-left-color: var(--primary) !important; 
            background-color: #283142 !important; /* Ligeramente m√°s claro que el panel */
            transform: scale(1.02) !important; 
            z-index: 100 !important;
            opacity: 1 !important; 
            filter: none !important; 
            box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.5) !important;
            border-top: 1px solid var(--primary) !important;
            border-bottom: 1px solid var(--primary) !important;
            border-right: 1px solid var(--primary) !important;
        }
        
        .line-content { display: flex; gap: 10px; align-items: flex-start; }
        .text-block { flex: 1; }
        .english { font-size: 1.1rem; font-weight: 500; line-height: 1.6; color: var(--text-main); margin-bottom: 8px; }
        .spanish { font-size: 0.95rem; color: var(--text-sec); border-top: 1px solid var(--border); padding-top: 8px; display: none; line-height: 1.4; font-style: italic;}
        .spanish.visible { display: block; animation: fadeIn 0.3s ease; }
        
        /* === MODIFICACI√ìN: DIVIDIR BOT√ìN PLAY === */
        .controls { display: flex; flex-direction: column; gap: 5px; min-width: 60px; margin-top: -2px; }
        .btn { border: none; border-radius: 6px; padding: 6px 0; font-size: 11px; font-weight: 700; cursor: pointer; width: 100%; text-transform: uppercase; letter-spacing: 0.5px; }
        
        /* NUEVO: Contenedor para botones divididos */
        .split-btn-group { display: flex; gap: 4px; width: 100%; }
        
        .playBtn { background-color: var(--border); color: white; transition: 0.2s; flex: 1; }
        .playBtn:hover { background-color: var(--primary); }
        
        /* NUEVO: Bot√≥n marcador */
        .markBtn { 
            background-color: #374151; color: #9ca3af; 
            flex: 0 0 24px; /* Ancho fijo */
            display: flex; align-items: center; justify-content: center; padding: 0; 
            font-size: 14px;
        }
        .markBtn:hover { background-color: var(--primary); color: white; }
        /* Estado cuando se ha marcado el inicio */
        .markBtn.active-start { background-color: #fbbf24; color: black; animation: pulse 1s infinite; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

        .speakBtn { background-color: transparent; border: 1px solid var(--border); color: var(--text-sec); transition: 0.2s; }
        .speakBtn:hover { border-color: var(--text-sec); color: white; }
        
        .saveBtn { background-color: transparent; border: 1px solid var(--success); color: var(--success); font-size: 16px; padding: 2px 0; line-height: 1; transition: 0.2s; }
        .saveBtn:hover { background-color: var(--success); color: black; }
        
        .word-interactive { border-radius: 4px; padding: 2px 1px; cursor: pointer; display: inline-block; border-bottom: 2px solid transparent; transition: all 0.2s; }
        .word-interactive:hover { background-color: rgba(99, 102, 241, 0.2); border-bottom-color: var(--primary); color: white; }
        
        /* PALABRAS GUARDADAS (ROSA) - Sin subrayado */
        .word-interactive.english-word.saved-word { 
            color: var(--saved-word) !important; 
            font-weight: 700; 
            border-bottom: none !important; /* Aqu√≠ eliminamos el subrayado */
        }
        .word-interactive.spanish-word.selected-word { color: var(--danger); font-weight: 700; }

        /* === BARRA INFERIOR === */
        #control-bar { 
            position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%); 
            background: rgba(31, 41, 55, 0.95); /* Gris oscuro semi-transparente */
            backdrop-filter: blur(10px); color: white; 
            padding: 8px 16px; border-radius: 50px; 
            display: flex; align-items: center; gap: 10px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); 
            z-index: 900; min-width: 340px; justify-content: space-between; 
            overflow-x: auto; scrollbar-width: none; border: 1px solid var(--border);
        }
        #control-bar::-webkit-scrollbar { display: none; }
        @media (max-width: 700px) { #control-bar { bottom: 0; left: 0; transform: none; width: 100%; border-radius: 0; justify-content: space-evenly; padding: 12px 15px; gap: 10px; } }

        .bar-btn, .bar-divider, .nav-count { flex-shrink: 0; }
        .bar-btn { 
            background: transparent; border: none; color: var(--text-sec); 
            width: 40px; height: 40px; border-radius: 50%; 
            display: flex; align-items: center; justify-content: center; 
            font-size: 18px; cursor: pointer; transition: 0.2s; 
        }
        .bar-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .bar-btn.active-state { background: var(--primary); color: white; box-shadow: 0 0 15px rgba(99, 102, 241, 0.5); }
        .bar-btn.disabled { opacity: 0.3; pointer-events: none; }
        .bar-divider { width: 1px; height: 24px; background: var(--border); }
        .nav-count { font-size: 13px; font-weight: 600; color: var(--text-main); min-width: 45px; text-align: center; }
        
        .popup-menu { 
            position: fixed; bottom: 90px; left: 50%; transform: translateX(-50%); 
            background: var(--bg-panel); border: 1px solid var(--border);
            padding: 15px; border-radius: 16px; color: white; display: none; 
            flex-direction: column; gap: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.5); 
            z-index: 950; min-width: 220px; 
        }
        .popup-menu.active { display: flex; animation: slideUp 0.2s ease; }
        .timing-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; font-weight: 600; color: var(--text-sec); }
        .timing-input { width: 60px; background: var(--bg-input); border: 1px solid var(--border); color: white; border-radius: 6px; padding: 6px; text-align: center; font-family: 'Inter', sans-serif; }
        .slider-label { font-size: 12px; text-align: center; color: var(--text-sec); margin-bottom: 5px; text-transform: uppercase; font-weight: 700; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: var(--primary); }
        @keyframes slideUp { from { opacity: 0; transform: translate(-50%, 10px); } to { opacity: 1; transform: translate(-50%, 0); } }
        
        #home-btn { 
            position: fixed; top: 15px; left: 15px; z-index: 600; 
            background: rgba(31, 41, 55, 0.8); color: white; border: 1px solid var(--border);
            padding: 8px 14px; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: 700; 
            backdrop-filter: blur(4px); transition: 0.2s;
        }
        #home-btn:hover { background: var(--primary); border-color: var(--primary); }
    
        #nexus-portal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 5000; background: var(--bg-body); }
        #nexus-frame { width: 100%; height: 100%; border: none; display: block; }

        @media (min-width: 801px) {
            .video-inner { border-radius: 20px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
            .video-wrapper { border-radius: 20px; overflow: hidden; background: transparent; box-shadow: none; border: none; }
            #video-cover { border-radius: 20px; }
        }

        /* OPCI√ìN 1 MEJORADA: Efecto Continuo (Highlighter) */
/* === SISTEMA H√çBRIDO (Transparente Separado -> S√≥lido Unido) === */

        /* 1. ESTADO GUARDADO (Ya en memoria: S√≥lido y UNIDO) */
        .word-interactive.phrase-word { 
            background-color: #fbbf24 !important; /* √Åmbar S√≥lido */
            color: #111827 !important;            /* Texto oscuro */
            
            /* TRUCO DE UNI√ìN (Para que parezca una sola cinta) */
            margin: 0 -1px !important; 
            box-shadow: 5px 0 0 #fbbf24, -5px 0 0 #fbbf24 !important;
            padding: 2px 0 !important;
            border-radius: 0 !important;
            
            position: relative;
            z-index: 1; 
            font-weight: 700;
            border-bottom: none;
        }

        /* 2. ESTADO PRE-SELECCI√ìN (Seleccionando: Transparente y SEPARADO) */
        .word-interactive.phrase-word[data-user-selected="true"] {
            background-color: rgba(251, 191, 36, 0.5) !important; /* Transparente */
            color: white !important; 
            
            /* SEPARACI√ìN VISUAL (Cajitas individuales) */
            box-shadow: none !important;        /* Quitamos la sombra que une */
            margin: 0 1px !important;           /* Ponemos margen para separar */
            border-radius: 4px !important;      /* Bordes redondeados individuales */
            padding: 2px 2px !important;        
            
            border-bottom: 2px solid #fbbf24 !important; /* Borde inferior para guiar */
            z-index: 10;
        }

        /* 3. DETALLE FINAL: Bordes redondeados solo en los extremos de la frase GUARDADA */
        .word-interactive.phrase-word:not([data-user-selected="true"]):first-child { 
            border-top-left-radius: 4px !important; border-bottom-left-radius: 4px !important; 
        }
        .word-interactive.phrase-word:not([data-user-selected="true"]):last-child { 
            border-top-right-radius: 4px !important; border-bottom-right-radius: 4px !important; 
        }
        .word-interactive { transition: background-color 0.2s, color 0.2s; }
        .line, .word-interactive, .english, .spanish, .h-title, .setup-card { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
        .spanish-word { cursor: default !important; }
        
        #trans-result-box { 
            font-size: 13px; color: #a5f3fc; font-weight: 700; 
            max-width: 150px; 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 
            margin-left: 8px; display: none; flex-shrink: 0; 
            background: rgba(255,255,255,0.1); padding: 4px 8px; border-radius: 6px;
        }

        /* === FRAGMENT MANAGER STYLES (Updated to Dark V16) === */
        #fragment-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 3000; justify-content: center; align-items: center; backdrop-filter: blur(8px); }
        .frag-container { 
            background: var(--bg-panel); width: 95%; max-width: 1000px; height: 85%; 
            border-radius: 16px; display: flex; flex-direction: column; 
            border: 1px solid var(--border); box-shadow: 0 20px 50px rgba(0, 0, 0, 0.7); overflow: hidden; 
        }
        .frag-header { padding: 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: #18202f; }
        .frag-title { color: white; font-size: 18px; font-weight: 800; }
        .frag-close { background: transparent; border: none; color: var(--text-sec); font-size: 24px; cursor: pointer; transition: 0.2s; }
        .frag-close:hover { color: white; }
        .frag-body { flex: 1; overflow-y: auto; padding: 20px; background: var(--bg-body); }
        
        /* UPDATED CONTROLS STYLING (NOWRAP + FIXED SQUASHING) */
        .frag-controls { 
            display: flex; gap: 20px; margin-bottom: 20px; align-items: center; 
            background: var(--bg-panel); padding: 15px; border-radius: 12px; border: 1px solid var(--border);
            flex-wrap: nowrap; white-space: nowrap; overflow-x: auto; 
        }
        .frag-controls::-webkit-scrollbar { display: none; }
        
        /* Forces minimum width so text doesn't wrap/squash on phone */
        .frag-slider-group { display: flex; flex-direction: column; gap: 5px; flex: 0 0 auto; min-width: 260px; }
        
        .frag-slider-label { font-size: 11px; color: var(--text-sec); font-weight: 700; text-transform: uppercase; display: flex; justify-content: space-between; margin-bottom: 5px; }
        input[type=range].frag-slider { -webkit-appearance: none; width: 100%; height: 6px; background: #374151; border-radius: 5px; outline: none; }
        input[type=range].frag-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%; background: var(--primary); cursor: pointer; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }

        .frag-btn { 
            background: #374151; color: white; border: none; padding: 10px 20px; border-radius: 8px; 
            cursor: pointer; font-size: 13px; font-weight: 700; display: flex; align-items: center; gap: 8px; 
            transition: 0.2s; white-space: nowrap; height: 42px; flex: 0 0 auto; 
        }
        .frag-btn:hover { background: #4b5563; }
        .frag-btn.primary { background: var(--primary); }
        .frag-btn.primary:hover { background: var(--primary-hover); }
        
        .frag-btn.auto-slice { background: linear-gradient(135deg, var(--primary) 0%, #8b5cf6 100%); box-shadow: 0 4px 10px rgba(79, 70, 229, 0.3); }
        .frag-btn.auto-slice:hover { transform: translateY(-1px); box-shadow: 0 6px 15px rgba(79, 70, 229, 0.4); }

        .frag-btn-danger-text { background: transparent; color: var(--danger); border: 1px solid rgba(239, 68, 68, 0.3); padding: 6px 12px; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; transition: 0.2s; }
        .frag-btn-danger-text:hover { background: rgba(239, 68, 68, 0.1); border-color: var(--danger); }

        .frag-table { width: 100%; border-collapse: collapse; color: var(--text-main); font-size: 13px; }
        .frag-table th { text-align: left; padding: 12px; border-bottom: 2px solid var(--border); color: var(--text-sec); text-transform: uppercase; font-size: 11px; white-space: nowrap; background: #18202f; }
        .frag-table td { padding: 10px 12px; border-bottom: 1px solid var(--border); vertical-align: middle; white-space: nowrap; }
        .frag-row:hover { background: rgba(255,255,255,0.03); }
        .frag-row.active-loop { background: rgba(99, 102, 241, 0.1); border-left: 3px solid var(--primary); }
        
        /* MANUAL ROW STYLE */
        .frag-row.manual { border-left: 3px solid #06b6d4; background: rgba(6, 182, 212, 0.05); }
        .frag-row.manual:hover { background: rgba(6, 182, 212, 0.1); }
        .frag-row.manual.active-loop { border-left: 3px solid var(--primary); background: rgba(99, 102, 241, 0.1); }

        .status-badge { padding: 4px 8px; border-radius: 12px; font-size: 10px; font-weight: 700; text-transform: uppercase; cursor: pointer; display: inline-block; min-width: 70px; text-align: center; }
        .st-new { background: rgba(239, 68, 68, 0.2); color: #fca5a5; border: 1px solid rgba(239, 68, 68, 0.3); }
        .st-study { background: rgba(245, 158, 11, 0.2); color: #fcd34d; border: 1px solid rgba(245, 158, 11, 0.3); }
        .st-master { background: rgba(16, 185, 129, 0.2); color: #6ee7b7; border: 1px solid rgba(16, 185, 129, 0.3); }

        .metric-pill { background: #374151; padding: 2px 6px; border-radius: 4px; font-family: monospace; font-size: 11px; color: #a5f3fc; display: inline-block; margin: 1px; }
        
        .time-inputs-container { display: flex; align-items: center; gap: 4px; }
        .frag-input-qty { width: 32px; background: rgba(0,0,0,0.2); border: 1px solid #4b5563; color: white; border-radius: 4px; padding: 4px 0; font-family: monospace; font-size: 12px; text-align: center; }
        .frag-input-qty:focus { border-color: var(--primary); outline: none; }
        .btn-set-time { background: #4b5563; border: none; color: white; border-radius: 4px; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 12px; margin-left: 6px; transition: 0.2s;}
        .btn-set-time:hover { background: var(--primary); }
        
        .frag-btn-del {
            background: transparent; border: none; color: var(--danger); font-size: 16px; cursor: pointer;
            width: 30px; height: 30px; display: flex; align-items: center; justify-content: center;
            border-radius: 50%; transition: 0.2s;
        }
        .frag-btn-del:hover { background: rgba(239, 68, 68, 0.1); }

        body.focus-mode .line:not(.active-loop-range) { opacity: 0.1; filter: blur(3px); pointer-events: none; transition: all 0.5s; }
        .line.active-loop-range { opacity: 1; filter: none; transform: scale(1.01); border-left-color: var(--highlight); background: #283142; z-index: 10; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }

    </style>
</head>
<body>

<div id="setup-screen">
    <div class="setup-container">
        <div class="setup-card">
            <div class="setup-title">‚ú® New Session</div>
            <div class="input-group">
                <label class="input-label">1. Video ID or URL</label>
                <input type="text" id="input-yt-id" class="text-input" placeholder="Paste YouTube URL..." autocomplete="off">
            </div>
            <div class="input-group">
                <label class="input-label">T√≠tulo del Video (Opcional)</label>
                <input type="text" id="input-video-title" class="text-input" placeholder="Type the title manually if it doesn't load..." autocomplete="off">
            </div>
            <div class="input-group">
                <label class="input-label">Category</label>
                <select id="input-category" class="text-input">
                    <option value="Talks">Talks</option>
                    <option value="Tutorial">Tutorial</option>
                    <option value="Interview">Interview</option>
                    <option value="Movie">Movie</option>
                    <option value="Podcast">Podcast</option>
                    <option value="Music">Music</option>
                    <option value="Documentary">Documentary</option>
                    <option value="Other">Other</option>
                </select>
            </div>
            <div class="input-group">
                <label class="input-label">2. Subtitles (.srt)</label>
                <div class="file-upload-btn" id="btn-upload-en" style="margin-bottom: 10px;">
                    <span>üá∫üá∏ Upload English</span>
                    <input type="file" id="file-en" accept=".srt" onchange="handleFileSelect(this, 'btn-upload-en')">
                </div>
                <div class="file-upload-btn" id="btn-upload-es">
                    <span>üá™üá∏ Upload Spanish</span>
                    <input type="file" id="file-es" accept=".srt" onchange="handleFileSelect(this, 'btn-upload-es')">
                </div>
            </div>
            <button class="start-btn" onclick="startNewSession()">LOAD STUDIO üöÄ</button>
        </div>

        <div class="setup-card">
            <button onclick="openNexus()" style="
                width: 100%; padding: 14px; margin-bottom: 15px; background: #374151; color: white; border: none; border-radius: 8px; font-weight: 700; font-size: 13px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s; box-shadow: 0 4px 6px rgba(0,0,0,0.1); text-transform: uppercase; letter-spacing: 0.5px;
            " onmouseover="this.style.background='#4b5563'" onmouseout="this.style.background='#374151'">
                üé¥ Video Cards
            </button>

            <div class="cat-filter-container">
                <button class="cat-btn active" onclick="setCategoryFilter('All')">All</button>
                <button class="cat-btn" onclick="setCategoryFilter('Talk')">Talks</button>
                <button class="cat-btn" onclick="setCategoryFilter('Tutorial')">Tutorial</button>
                <button class="cat-btn" onclick="setCategoryFilter('Interview')">Interview</button>
                <button class="cat-btn" onclick="setCategoryFilter('Movie')">Movie</button>
                <button class="cat-btn" onclick="setCategoryFilter('Podcast')">Podcast</button>
                <button class="cat-btn" onclick="setCategoryFilter('Music')">Music</button>
                <button class="cat-btn" onclick="setCategoryFilter('Documentary')">Documentary</button>
            </div>

            <div class="library-section" id="library-container">
                <div class="library-label">üî• Library</div>
                <div id="library-list" class="history-list">
                    <div class="empty-history">Waiting for connection...</div>
                </div>
            </div>
            
            <div class="setup-title">üìö History</div>
            <div id="history-container" class="history-list">
                <div class="empty-history">No recent history.</div>
            </div>
            <div class="backup-actions">
                <button class="backup-btn" onclick="exportBackup()">üíæ Backup</button>
                <div class="backup-btn">
                    <span>üìÇ Restore</span>
                    <input type="file" accept=".json" onchange="importBackup(this)">
                </div>
            </div>
        </div>
    </div>
</div>

<div id="fragment-modal">
    <div class="frag-container">
        <div class="frag-header">
            <div class="frag-title">üß© Study Fragments</div>
            <div style="display:flex; gap:10px; align-items:center;">
                <button class="frag-btn-danger-text" onclick="deleteAllFragments()">üóë Delete All</button>
                <button class="frag-close" onclick="toggleFragmentsMenu()">√ó</button>
            </div>
        </div>
        <div class="frag-body">
            
      <div class="frag-controls">
                
                <div class="frag-slider-group">
                    <div class="frag-slider-label">
                        <span>Fragment Size</span>
                        <span id="frag-slider-val" style="color:#a5f3fc">Manual (Current + 5m)</span>
                    </div>
                    <input type="range" class="frag-slider" min="0" max="20" step="1" value="0" oninput="updateSliceUI(this.value)">
                </div>

                <button class="frag-btn primary" id="btn-add-smart" onclick="handleAddSmartFragment()">
                    <span>‚ûï New Fragment</span>
                </button>

                <button class="frag-btn" onclick="openNexus('FOCUS')" style="
                    background: linear-gradient(135deg, #bd00ff 0%, #7c3aed 100%); 
                    box-shadow: 0 4px 10px rgba(189, 0, 255, 0.3);
                    border: 1px solid rgba(255,255,255,0.1);
                ">
                    <span>üé¥ Cards Focus</span>
                </button>
                <div style="margin-left: auto; display: flex; gap: 10px; align-items: center; color: #9ca3af; font-size: 12px; flex: 0 0 auto;">
                    <span id="total-time-studied">Total Study: 0m</span>
                </div>
            </div>

            <div style="overflow-x: auto;">
                <table class="frag-table">
                    <thead>
                        <tr>
                            <th style="width: 80px;">Status</th>
                            <th>Name</th>
                            <th>Start (H : M : S)</th>
                            <th>End (H : M : S)</th>
                            <th>Vocab Saved</th>
                            <th>Time Spent</th>
                            <th style="width: 100px;">Actions</th>
                            <th style="width: 40px;"></th>
                        </tr>
                    </thead>
                    <tbody id="frag-table-body">
                        </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<div id="player-ui">
    <button id="home-btn" onclick="goHome()">üè† Back</button>

    <div class="page-max-width">
        <div class="video-wrapper">
            <div class="video-inner">
                <div id="video-cover" onclick="activateVideo()"></div>
                <div id="player"></div>
            </div>
        </div>
        <div class="dialogue-container" id="dialogue-root"></div>
    </div>
    
    <div id="timing-menu" class="popup-menu">
        <div class="timing-row"><span>Start Offset (s)</span><input type="number" step="0.1" id="input-time-offset" class="timing-input" onchange="updateTimingSettings()"></div>
        <div class="timing-row"><span>End Padding (s)</span><input type="number" step="0.1" id="input-end-padding" class="timing-input" onchange="updateTimingSettings()"></div>
    </div>
    
    <div id="position-menu" class="popup-menu">
        <div class="slider-label">Vertical Position</div>
        <input type="range" id="vertical-slider" min="-300" max="300" value="0" step="10" oninput="updateVerticalOffset(this.value)">
        <div class="slider-label" style="font-size:10px; margin-top:5px; opacity:0.7;">Up &nbsp; &nbsp; ‚Üî &nbsp; &nbsp; Down</div>
    </div>

    <div id="control-bar">
        <button class="bar-btn" id="btn-home" onclick="goHome()" title="Back to Home">üè†</button>
        <div class="bar-divider"></div>
        <div class="nav-count" id="nav-counter" style="margin: 0 10px;">0/0</div>
        <div class="bar-divider"></div>
        <button class="bar-btn" id="btn-speak-word" onclick="speakActiveOrSelected()">üì¢</button>
        <div id="trans-result-box">...</div>
        <div class="bar-divider"></div>
        <button class="bar-btn" id="btn-fragments" onclick="toggleFragmentsMenu()" title="Manage Fragments" style="font-size: 16px;">üß©</button>
        <button class="bar-btn" id="btn-speed" onclick="cycleSpeed()" style="width:auto; padding:0 8px; font-size:12px; font-weight:700;">1x</button>
        <button class="bar-btn" id="btn-timing" onclick="toggleMenu('timing-menu')" style="font-size: 16px;">‚è±Ô∏è</button>
        <button class="bar-btn" id="btn-position" onclick="toggleMenu('position-menu')" style="font-size: 18px;">‚ÜïÔ∏è</button>
        <div class="bar-divider"></div>
        <button class="bar-btn" id="btn-loop" onclick="toggleLoop()" style="font-size: 16px;">üîÅ</button>
        <button class="bar-btn" id="btn-mirror" onclick="toggleMirror()" style="font-size: 16px;">ü™û</button>
        <button class="bar-btn" id="btn-autoscroll" onclick="toggleAutoScroll()" style="color: #6366f1;">üîí</button>
        <button class="bar-btn" id="btn-toggle-trans" onclick="toggleAllTranslations()">üëÅÔ∏è</button>
        <button class="bar-btn disabled" id="btn-clear" onclick="clearAllWords()">üóëÔ∏è</button>
    </div>
</div>

<div id="nexus-portal">
    <iframe id="nexus-frame" src="" allow="autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

<script>
    let YOUTUBE_ID = '';
    let VIDEO_TITLE = 'Saved from Studio';
    let SUBTITLES_DATA = [];
    let lastSelectedWordText = ""; 
    // NUEVA VARIABLE: Guarda qu√© palabra est√° actualmente en la barra (sea por click o hover)
    let currentPillText = ""; 

    const HISTORY_KEY = 'mdc_studio_history';
    const VOCAB_KEY = 'mdc_vocab_list';
    const LIBRARY_URL = 'https://paradisonetworx.com/biblioteca.json'; 
    let REMOTE_LIBRARY = [];
    let activeCategoryFilter = 'All';
    let lastStorageString = "";
    let currentWordStats = { occurrences: "-", uniqueTotal: 0 };
    let lineObserver; 
    
    let savedTimestamps = [];
    let pressTimer;
    let isLongPressHandled = false;
    let pendingPhraseStartIdx = null; 

    // === FRAGMENT MANAGER VARS ===
    let STORAGE_KEY_FRAGMENTS = "";
    let videoFragments = []; 
    let activeFragmentId = null; 
    let fragmentStartTime = null; 
    let fragmentSliceMinutes = 0; 

    // === NEW VAR: FRAGMENT MARKER LOGIC ===
    let pendingMarkerStart = null;

    // === L√ìGICA DE HOVER (CORREGIDO: Ahora est√° en el √°mbito global) ===
    let hoverTimerRef;

    function handleHoverStart(el) {
        clearTimeout(hoverTimerRef);
        // Iniciamos el contador de 0.5 segundos (500ms)
        hoverTimerRef = setTimeout(() => {
            const rawText = el.innerText.replace(/[^a-zA-Z0-9]/g, "");
            // Esto actualiza la barra y la variable de audio
            translateWordForBar(rawText);
        }, 500);
    }

    function handleHoverEnd() {
        clearTimeout(hoverTimerRef);
    }
    // ==================================================================

    document.addEventListener('DOMContentLoaded', () => { 
        renderHistoryList();
        loadRemoteLibrary(); 
        startStorageWatcher();
    });

    function startStorageWatcher() {
        lastStorageString = localStorage.getItem(VOCAB_KEY) || "";
        setInterval(() => {
            const currentString = localStorage.getItem(VOCAB_KEY) || "";
            if (currentString !== lastStorageString) {
                lastStorageString = currentString;
                updateAllWordStates(); 
            }
        }, 1000); 
    }

    function setCategoryFilter(category) {
        activeCategoryFilter = category;
        document.querySelectorAll('.cat-btn').forEach(btn => {
            if(btn.innerText === category) btn.classList.add('active');
            else btn.classList.remove('active');
        });
        renderHistoryList();
        renderLibraryItems();
    }

    async function loadRemoteLibrary() {
        const list = document.getElementById('library-list');
        list.innerHTML = '<div class="empty-history" style="color:#6366f1;">‚è≥ Buscando videos...</div>';
        try {
            const response = await fetch(LIBRARY_URL + '?t=' + new Date().getTime());
            if (!response.ok) throw new Error("Error de conexi√≥n");
            REMOTE_LIBRARY = await response.json();
            if (REMOTE_LIBRARY.videos) REMOTE_LIBRARY = REMOTE_LIBRARY.videos;
            else if (!Array.isArray(REMOTE_LIBRARY)) REMOTE_LIBRARY = [];
            renderLibraryItems(); 
        } catch (error) {
            console.error(error);
            list.innerHTML = `<div class="empty-history" style="color:#ef4444;">‚ùå No se pudo cargar la biblioteca.</div>`;
        }
    }

    function renderLibraryItems() {
        const list = document.getElementById('library-list');
        list.innerHTML = '';
        const filteredLib = (activeCategoryFilter === 'All') 
            ? REMOTE_LIBRARY 
            : REMOTE_LIBRARY.filter(item => item.category === activeCategoryFilter);

        if(filteredLib.length === 0) { list.innerHTML = '<div class="empty-history">Empty.</div>'; return; }
        
        filteredLib.forEach((item, index) => {
            const originalIndex = REMOTE_LIBRARY.indexOf(item);
            const div = document.createElement('div');
            div.className = 'history-item';
            div.style.borderLeft = "4px solid #6366f1";
            div.onclick = () => loadFromLibrary(originalIndex);
            const catDisplay = item.category ? `<span class="h-tag">${item.category}</span>` : '';
            div.innerHTML = `
                <div class="h-thumb" style="background-image: url('https://img.youtube.com/vi/${item.id}/default.jpg')"></div>
                <div class="h-info">
                    <div class="h-title">${item.title}</div>
                    <div class="h-date">
                        <div class="h-tag">${catDisplay}</div>
                    </div>
                </div>
                <div style="font-size:18px; color:#aaa;">‚ñ∂</div>`;
            list.appendChild(div);
        });
    }

    function loadFromLibrary(index) {
        const item = REMOTE_LIBRARY[index];
        if(!item) return;
        if(player && typeof player.stopVideo === 'function') player.stopVideo();
        isSegmentPlaying = false; resetButtons(); YOUTUBE_ID = item.id; VIDEO_TITLE = item.title;
        processAndLaunch(item.srtEn, item.srtEs, item.id, item.title);
    }

    function handleFileSelect(input, btnId) {
        if(input.files && input.files[0]) {
            const btn = document.getElementById(btnId);
            btn.classList.add('loaded');
            btn.querySelector('span').innerText = "‚úì " + input.files[0].name;
        }
    }

    function extractVideoID(url) {
        const regExp = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=|shorts\/)|youtu\.be\/)([^"&?\/\s]{11})/;
        const match = url.match(regExp);
        return (match && match[1]) ? match[1] : false;
    }

   async function startNewSession() {
        const rawInput = document.getElementById('input-yt-id').value.trim();
        const manualTitle = document.getElementById('input-video-title').value.trim();
        const category = document.getElementById('input-category').value;
        let extractedID = extractVideoID(rawInput);
        
        if (!extractedID && rawInput.length === 11) extractedID = rawInput;
        if (!extractedID) return alert("‚ùå URL o ID de video inv√°lido.");
        
        YOUTUBE_ID = extractedID;
        
        const fileEn = document.getElementById('file-en').files[0];
        const fileEs = document.getElementById('file-es').files[0];
        
        if(!fileEn || !fileEs) return alert("‚ö†Ô∏è Carga ambos archivos SRT.");
        
        try {
            const textEn = await readFile(fileEn);
            const textEs = await readFile(fileEs);
            const finalTitle = manualTitle.length > 0 ? manualTitle : "Video Cargado";
            VIDEO_TITLE = finalTitle; 

            processAndLaunch(textEn, textEs, YOUTUBE_ID, finalTitle);
            addToHistory(YOUTUBE_ID, finalTitle, textEn, textEs, category);
            
        } catch (e) { alert("Error leyendo archivos: " + e); }
    }

    function loadFromHistory(id) {
        const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
        const item = history.find(i => i.id === id);
        if(item) {
            if(player && typeof player.stopVideo === 'function') player.stopVideo();
            isSegmentPlaying = false; resetButtons(); YOUTUBE_ID = item.id; VIDEO_TITLE = item.title;
            processAndLaunch(item.srtEn, item.srtEs, item.id, item.title);
        }
    }

    function processAndLaunch(srtEn, srtEs, id, title) {
        const parsedEn = parseSRT(srtEn);
        const parsedEs = parseSRT(srtEs);
        
        let globalWordCount = 0;
        SUBTITLES_DATA = parsedEn.map((item, index) => {
            const esItem = parsedEs[index] ? parsedEs[index].text : "...";
            const currentStartIdx = globalWordCount;
            const wordCount = item.text.trim().split(/\s+/).length; 
            globalWordCount += wordCount;
            
            return { 
                s: item.start, 
                e: item.end, 
                en: item.text, 
                es: esItem,
                wordStart: currentStartIdx 
            };
        });
        
        document.getElementById('setup-screen').style.display = 'none';
        document.getElementById('player-ui').style.display = 'flex';
        const cover = document.getElementById('video-cover');
        cover.style.backgroundImage = `url('https://img.youtube.com/vi/${id}/maxresdefault.jpg')`;
        cover.style.display = 'flex'; 
        
        renderSubtitles();
        
        loadPreferences();
        if(window.YT && window.YT.Player) {
            if(player) { player.loadVideoById(id); player.setPlaybackRate(currentPlaybackRate); } 
            else { onYouTubeIframeAPIReady(); }
        } else {
            const tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            document.getElementsByTagName('script')[0].parentNode.insertBefore(tag, document.getElementsByTagName('script')[0]);
        }
    }

    function activateVideo() {
        if(player && typeof player.playVideo === 'function') { player.playVideo(); } 
        else { setTimeout(activateVideo, 500); }
    }

    function goHome() {
        if(player) player.pauseVideo();
        document.getElementById('player-ui').style.display = 'none';
        document.getElementById('setup-screen').style.display = 'flex';
        renderHistoryList();
    }

    function addToHistory(id, title, srtEn, srtEs, category = 'Other') {
        let history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
        history = history.filter(item => item.id !== id);
        history.unshift({ id, title, srtEn, srtEs, category, date: new Date().getTime() });
        if(history.length > 50) history.pop(); 
        localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    }

    function updateHistoryTitle(id, newTitle) {
        let history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
        const idx = history.findIndex(i => i.id === id);
        if(idx !== -1) { history[idx].title = newTitle; localStorage.setItem(HISTORY_KEY, JSON.stringify(history)); }
    }

    function deleteHistoryItem(e, id) {
        e.stopPropagation();
        if(!confirm('¬øBorrar este video del historial?')) return;
        let history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
        history = history.filter(i => i.id !== id);
        localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
        renderHistoryList();
    }

    function renderHistoryList() {
        const list = document.getElementById('history-container');
        const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
        
        const filteredHistory = (activeCategoryFilter === 'All') 
            ? history 
            : history.filter(item => (item.category || 'Other') === activeCategoryFilter);

        if(filteredHistory.length === 0) { list.innerHTML = '<div class="empty-history">Empty.</div>'; return; }
        
        list.innerHTML = '';
        filteredHistory.forEach(item => {
            const date = new Date(item.date).toLocaleDateString();
            const cat = item.category || 'Other';
            const div = document.createElement('div');
            div.className = 'history-item';
            div.onclick = () => loadFromHistory(item.id);
           div.innerHTML = `
            <div class="h-thumb" style="background-image: url('https://img.youtube.com/vi/${item.id}/default.jpg')"></div>
            <div class="h-info">
                <div class="h-title">${item.title}</div>
                <div class="h-date">
                    <span class="h-tag">${cat}</span>
                    <span>${date}</span>
                </div>
            </div>
            <button class="h-btn-copy" onclick="copyHistoryData(event, '${item.id}', this)" title="Copiar c√≥digo fuente del video">üìã</button>
            <button class="h-btn-del" onclick="deleteHistoryItem(event, '${item.id}')">‚úï</button>
        `;
        list.appendChild(div);
    });
    }

    function exportBackup() {
        const data = {};
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if(key.startsWith('mdc_')) data[key] = localStorage.getItem(key);
        }
        const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `mdc_backup_${new Date().toISOString().slice(0,10)}.json`;
        a.click();
    }

    function importBackup(input) {
        if(!input.files || !input.files[0]) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                Object.keys(data).forEach(key => localStorage.setItem(key, data[key]));
                alert("Restauraci√≥n completada."); location.reload();
            } catch(err) { alert("Archivo inv√°lido."); }
        };
        reader.readAsText(input.files[0]);
    }

    function readFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(e);
            reader.readAsText(file);
        });
    }
    
    function sanitizeText(text) {
        if (!text) return "";
        text = text.replace(/\u00A0/g, " "); 
        text = text.replace(/['`‚Äò¬¥]/g, "‚Äô");
        text = text.replace(/[^a-zA-Z0-9\u00C0-\u017F\s‚Äô]/g, "");
        return text.trim();
    }

    function parseSRT(text) {
        const pattern = /(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})\n([\s\S]*?)(?=\n\n|\n*$|\d+\n\d{2}:)/g;
        let result = []; let match;
        const cleanText = text.replace(/\r\n/g, '\n').replace(/\n\r/g, '\n');
        while ((match = pattern.exec(cleanText)) !== null) {
        result.push({ start: timeToSec(match[1]), end: timeToSec(match[2]), text: match[3].replace(/\n/g, ' ').replace(/<[^>]*>/g, '').replace(/[‚ô™‚ô´‚ô¨]/g, '').replace(/>>/g, '').replace(/^\s*-\s+/g, '').trim() });                
        }
        return result;
    }
    function timeToSec(t) {
        const [h, m, s] = t.split(':'); const [sec, ms] = s.split(',');
        return parseInt(h) * 3600 + parseInt(m) * 60 + parseInt(sec) + parseInt(ms) / 1000;
    }

    let timeOffset = 0.0, endPadding = 0.0;
    const TTS_RATE = 0.65; const TTS_LANG = 'en-US';
    let STORAGE_KEY_ESP, STORAGE_KEY_TIME;
    const PREF_SPEED='mdc_pref_speed', PREF_SCROLL='mdc_pref_scroll', PREF_TRANS='mdc_pref_trans', PREF_TIMING='mdc_pref_timing', PREF_OFFSET='mdc_pref_v_offset';
    let player, checkInterval, isSegmentPlaying=false, segmentEndTime=0, scrollEnabled=true, autoScroll=true;
    let currentPlaybackRate = 1.0, allVisible = false;
    let isLooping = false;
    let isMirrorActive = false; 
    let currentVerticalOffset = 0;

    window.onYouTubeIframeAPIReady = function() {
        if(!YOUTUBE_ID) return; 
        if(player && typeof player.destroy === 'function') { player.destroy(); }
        player = new YT.Player('player', {
            videoId: YOUTUBE_ID,
            playerVars: { playsinline: 1, rel: 0, modestbranding: 1, controls: 1, autoplay: 1 },
            events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateChange }
        });
    };

 function onPlayerReady(event) {
        const data = player.getVideoData();
        if(data && data.title && VIDEO_TITLE === 'Video Cargado') { 
            VIDEO_TITLE = data.title; 
            updateHistoryTitle(YOUTUBE_ID, data.title); 
        }
        
        const savedTime = localStorage.getItem(STORAGE_KEY_TIME);
        if (savedTime) { 
            const t = parseFloat(savedTime);
            player.seekTo(t); 
            player.pauseVideo(); 
            
            highlightCurrentLine(t);
            
            const activeLine = document.querySelector('.line.active');
            const container = document.querySelector('.dialogue-container');
            
            if (activeLine && container) {
                const target = activeLine.offsetTop - (container.clientHeight / 2) + (activeLine.offsetHeight / 2) + currentVerticalOffset;
                container.scrollTo({ top: target, behavior: "auto" }); 
            }
        }
        player.setPlaybackRate(currentPlaybackRate);
    }

    function onPlayerStateChange(event) {
        if (event.data === YT.PlayerState.PLAYING) { 
            const cover = document.getElementById('video-cover');
            if(cover) cover.style.display = 'none';
            clearInterval(checkInterval); 
            checkInterval = setInterval(checkTime, 100); 
        }
        else { 
            clearInterval(checkInterval); 
            if(player && player.getCurrentTime) localStorage.setItem(STORAGE_KEY_TIME, player.getCurrentTime()); 
        }
    }

    function checkTime() {
        if (!player || !player.getCurrentTime) return;
        const currentTime = player.getCurrentTime();
        if (Math.floor(currentTime) % 5 === 0) localStorage.setItem(STORAGE_KEY_TIME, currentTime);
        
if (activeFragmentId) {
    const frag = videoFragments.find(f => f.id === activeFragmentId);
    if (frag) {
        if (!document.body.classList.contains('focus-mode')) {
            document.body.classList.add('focus-mode');
        }
        
        document.querySelectorAll('.line').forEach(line => {
            const lStart = parseFloat(line.dataset.start);
            const lEnd = parseFloat(line.dataset.end);

            // === CAMBIO AQU√ç: MISMA L√ìGICA ESTRICTA ===
            
            if (lStart >= frag.start && lEnd <= (frag.end + 0.05)) {
                line.classList.add('active-loop-range');
            } else {
                line.classList.remove('active-loop-range');
            }
            // ==========================================
        });

               if (currentTime >= frag.end || currentTime < frag.start - 0.5) {
    player.pauseVideo();       // 1. Pausa el video
    player.seekTo(frag.start); // 2. Rebobina al inicio para la pr√≥xima vez
    return; 
}

                if (player.getPlayerState() === YT.PlayerState.PLAYING) {
                    trackFragmentTime(frag);
                }
            } else {
                activeFragmentId = null;
            }
        } else {
            if (document.body.classList.contains('focus-mode')) {
                document.body.classList.remove('focus-mode');
                document.querySelectorAll('.active-loop-range').forEach(l => l.classList.remove('active-loop-range'));
            }
        }

        if (isSegmentPlaying && currentTime >= segmentEndTime) {
            if (isMirrorActive) {
                player.pauseVideo(); isSegmentPlaying = false; 
                const activeBtn = document.querySelector('.playBtn[data-state="playing"]');
                const line = activeBtn ? activeBtn.closest('.line') : null;
                let durationMs = 2000;
                if(line) { durationMs = (parseFloat(line.dataset.end) - parseFloat(line.dataset.start)) * 1000; }
                setTimeout(() => {
                    if (activeBtn && activeBtn.dataset.state !== 'playing') return;
                    if (isLooping) {
                        if(line) {
                            const start = parseFloat(line.dataset.start) - timeOffset;
                            player.seekTo(Math.max(0, start), true); player.playVideo(); isSegmentPlaying = true;
                        }
                    } else {
                        const nextLine = line ? line.nextElementSibling : null;
                        if(nextLine && nextLine.classList.contains('line')) {
                            resetButtons(); nextLine.querySelector('.playBtn').click();
                            if(autoScroll) scrollToActiveElement(nextLine);
                        } else { resetButtons(); scrollEnabled = true; }
                    }
                }, durationMs);
                return;
            }
            if (isLooping) {
                const activeBtn = document.querySelector('.playBtn[data-state="playing"]');
                if(activeBtn) {
                    const line = activeBtn.closest('.line');
                    const start = parseFloat(line.dataset.start) - timeOffset;
                    player.seekTo(Math.max(0, start), true); return;
                }
            }
            player.pauseVideo(); isSegmentPlaying = false; resetButtons(); scrollEnabled = true; return;
        }
        if (scrollEnabled) highlightCurrentLine(currentTime);
    }

    function trackFragmentTime(fragment) {
        const now = Math.floor(Date.now() / 1000);
        if (fragmentStartTime !== now) {
            fragmentStartTime = now;
            fragment.timeSpent = (fragment.timeSpent || 0) + 1;
            localStorage.setItem(STORAGE_KEY_FRAGMENTS, JSON.stringify(videoFragments));
        }
    }

    function highlightCurrentLine(time) {
        const lines = document.querySelectorAll('.line'); let activeLine = null;
        lines.forEach((line) => {
            const start = parseFloat(line.dataset.start); const end = parseFloat(line.dataset.end);
            if (time >= start && time < end + endPadding) activeLine = line; 
            line.classList.remove('active');
        });
        if (activeLine) { activeLine.classList.add('active'); scrollToActiveElement(activeLine); }
    }
    
    function scrollToActiveElement(el) {
        if (!autoScroll) return;
        const container = document.querySelector('.dialogue-container');
        if (container && el) {
            const target = el.offsetTop - (container.clientHeight / 2) + (el.offsetHeight / 2) + currentVerticalOffset;
            container.scrollTo({ top: target, behavior: "smooth" });
        }
    }

    function renderSubtitles() {
        const root = document.getElementById('dialogue-root');
        let html = '';
        SUBTITLES_DATA.forEach(sub => {
            html += `
            <div class="line" data-start="${sub.s}" data-end="${sub.e}" data-word-start="${sub.wordStart}">
                <div class="line-content">
                    <div class="text-block">
                        <div class="english">${sub.en}</div>
                        <div class="spanish">${sub.es}</div>
                    </div>
                    <div class="controls">
                        <div class="split-btn-group">
                            <button class="btn playBtn" style="font-size: 14px;">‚ñ∂</button>
                            <button class="btn markBtn" onclick="handleMarkerClick(this)">‚öë</button>
                        </div>
                        <button class="btn speakBtn">Speak</button>
                        <button class="btn saveBtn" onclick="saveLineToVocab(this)">+</button>
                    </div>
                </div>
            </div>`;
        });
        root.innerHTML = html;
        attachButtonEvents();
        initLazyObserver();
        
        STORAGE_KEY_ESP = 'mdc_esp_' + YOUTUBE_ID; 
        STORAGE_KEY_TIME = 'mdc_time_' + YOUTUBE_ID;
        STORAGE_KEY_FRAGMENTS = 'mdc_fragments_' + YOUTUBE_ID; 
        loadFragments(); 
        highlightSavedFragments();
    }

    // === NEW FUNCTION: MARKER LOGIC ===
    function handleMarkerClick(btn) {
        const line = btn.closest('.line');
        const start = parseFloat(line.dataset.start);
        const end = parseFloat(line.dataset.end);

        if (pendingMarkerStart === null) {
            // SCENARIO 1: FIRST CLICK (START)
            pendingMarkerStart = start;
            
            // Visual feedback
            document.querySelectorAll('.markBtn').forEach(b => {
                b.style.opacity = '0.4'; // Dim others
                if(b === btn) {
                    b.classList.add('active-start');
                    b.style.opacity = '1';
                    b.innerText = "‚è≥";
                }
            });
        } else {
            // SCENARIO 2: SECOND CLICK (END)
            if (end <= pendingMarkerStart) {
                alert("End time must be AFTER start time! (Marker reset)");
                resetMarkerState();
                return;
            }

            // Create Fragment
            const newFrag = {
                id: Date.now().toString(),
                name: `Fragment ${videoFragments.length + 1} (${formatTimeShort(pendingMarkerStart)} - ${formatTimeShort(end)})`,
                start: pendingMarkerStart,
                end: end,
                status: 'new',
                timeSpent: 0,
                type: 'manual'
            };

            videoFragments.push(newFrag);
            localStorage.setItem(STORAGE_KEY_FRAGMENTS, JSON.stringify(videoFragments));
            
            // Show Feedback (Optional: Open panel or just alert)
            // alert("Fragment Created!"); 
            renderFragmentList(); // Update hidden list

            highlightSavedFragments();
            
            resetMarkerState();
            
            // Open Fragment menu briefly to show success? Or just leave it hidden.
            // Let's just reset state silently or maybe show a toast.
            const btnText = btn.innerText;
            btn.innerText = "‚úÖ";
            setTimeout(() => btn.innerText = "‚öë", 1000);
        }
    }

    function resetMarkerState() {
         pendingMarkerStart = null;
         document.querySelectorAll('.markBtn').forEach(b => {
             b.classList.remove('active-start');
             b.style.opacity = '';
             b.innerText = "‚öë";
         });
    }

    // === FRAGMENT MANAGER LOGIC ===

 function loadFragments() {
        const raw = localStorage.getItem(STORAGE_KEY_FRAGMENTS);
        if (raw) {
            try { videoFragments = JSON.parse(raw); } catch (e) { videoFragments = []; }
        } else {
            videoFragments = [];
        }

        const savedActiveId = localStorage.getItem('mdc_active_frag_' + YOUTUBE_ID);
        if (savedActiveId) {
            const exists = videoFragments.find(f => f.id === savedActiveId);
           if (exists) {
    activeFragmentId = savedActiveId;
    document.body.classList.add('focus-mode');
    setTimeout(() => {
        document.querySelectorAll('.line').forEach(line => {
            const lStart = parseFloat(line.dataset.start);
            const lEnd = parseFloat(line.dataset.end);

            // === CAMBIO AQU√ç: L√ìGICA ESTRICTA ===
            // Antes: if (lStart < exists.end && lEnd > exists.start)
            // Ahora: Comprobamos que la l√≠nea termine ANTES (o igual) al final del fragmento
            // (El +0.05 es una peque√±a tolerancia por si hay decimales, pero excluye al siguiente)
            
            if (lStart >= exists.start && lEnd <= (exists.end + 0.05)) {
                line.classList.add('active-loop-range');
            } else {
                line.classList.remove('active-loop-range');
            }
            // ====================================

        });
        const firstActive = document.querySelector('.active-loop-range');
        if(firstActive) scrollToActiveElement(firstActive);
    }, 50);
} else {
                localStorage.removeItem('mdc_active_frag_' + YOUTUBE_ID);
            }
        }
    }

    function toggleFragmentsMenu() {
        const modal = document.getElementById('fragment-modal');
        if (modal.style.display === 'flex') {
            modal.style.display = 'none';
            if (player) player.playVideo();
        } else {
            modal.style.display = 'flex';
            if (player) player.pauseVideo();
            renderFragmentList();
        }
    }

    function updateSliceUI(val) {
        fragmentSliceMinutes = parseInt(val);
        const label = document.getElementById('frag-slider-val');
        const btn = document.getElementById('btn-add-smart');
        
        if (fragmentSliceMinutes === 0) {
            label.innerText = "Manual (Current + 5m)";
            label.style.color = "#a5f3fc";
            btn.innerHTML = "<span>‚ûï New Fragment</span>";
            btn.className = "frag-btn primary";
        } else {
            label.innerText = `Auto-Slice (${fragmentSliceMinutes}m Segments)`;
            label.style.color = "#c084fc";
            btn.innerHTML = `<span>‚ö° Auto-Slice (${fragmentSliceMinutes}m)</span>`;
            btn.className = "frag-btn auto-slice";
        }
    }

    function handleAddSmartFragment() {
        if (fragmentSliceMinutes === 0) {
            addFragment();
        } else {
            bulkSliceVideo(fragmentSliceMinutes);
        }
    }

    function bulkSliceVideo(minutes) {
        if (!player || !player.getDuration) return alert("Wait for video to load.");
        if(!confirm(`This will divide the ENTIRE video into ${minutes} minute parts. Continue?`)) return;

        const duration = player.getDuration();
        const chunkSize = minutes * 60;
        
        for (let i = 0; i < duration; i += chunkSize) {
            const start = i;
            const end = Math.min(i + chunkSize, duration);
            const partNum = Math.floor(i / chunkSize) + 1;
            
            const newFrag = {
                id: Date.now().toString() + Math.random(),
                name: `Part ${partNum} (${formatTimeShort(start)} - ${formatTimeShort(end)})`,
                start: start,
                end: end,
                status: 'new',
                timeSpent: 0,
                type: 'auto'
            };
            videoFragments.push(newFrag);
        }
        
        localStorage.setItem(STORAGE_KEY_FRAGMENTS, JSON.stringify(videoFragments));
        renderFragmentList();
        highlightSavedFragments();
    }

    function makeTimeInputHTML(id, type, totalSeconds) {
    const h = Math.floor(totalSeconds / 3600);
    const m = Math.floor((totalSeconds % 3600) / 60);
    // Cambiamos la l√≥gica de segundos para mantener los decimales
    let s = (totalSeconds % 60).toFixed(3); 
    // Si prefieres que se vea m√°s limpio cuando es entero, puedes usar parseFloat para quitar ceros extra
    s = parseFloat(s); 

    return `
    <div class="time-inputs-container">
        <input type="number" min="0" class="frag-input-qty" value="${h}" onchange="updateFragTimeFromParts('${id}', '${type}', this.parentNode)">:
        <input type="number" min="0" max="59" class="frag-input-qty" value="${m}" onchange="updateFragTimeFromParts('${id}', '${type}', this.parentNode)">:
        <input type="number" min="0" max="59.999" step="0.001" class="frag-input-qty" value="${s}" onchange="updateFragTimeFromParts('${id}', '${type}', this.parentNode)">
        <button class="btn-set-time" onclick="captureTimeForFragment('${id}', '${type}')" title="Set to Now">üìç</button>
    </div>`;
}

    function updateFragTimeFromParts(id, type, parentDiv) {
    const inputs = parentDiv.querySelectorAll('input');
    const h = parseInt(inputs[0].value) || 0;
    const m = parseInt(inputs[1].value) || 0;
    // AQU√ç EL CAMBIO: Usar parseFloat en lugar de parseInt para los segundos
    const s = parseFloat(inputs[2].value) || 0;
    
    const totalSecs = (h * 3600) + (m * 60) + s;
    updateFragmentTime(id, type, totalSecs);
}

    function renderFragmentList() {
        const tbody = document.getElementById('frag-table-body');
        tbody.innerHTML = '';
        let totalSecs = 0;

        videoFragments.forEach(frag => {
            totalSecs += (frag.timeSpent || 0);
            const stats = calculateFragmentStats(frag.start, frag.end);
            const timeStudied = formatTime(frag.timeSpent || 0);

            const tr = document.createElement('tr');
            let rowClass = 'frag-row';
            if (activeFragmentId === frag.id) rowClass += ' active-loop';
            if (frag.type === 'manual') rowClass += ' manual';
            tr.className = rowClass;
            
            const statusClass = frag.status === 'master' ? 'st-master' : (frag.status === 'study' ? 'st-study' : 'st-new');
            const statusLabel = frag.status === 'master' ? 'Mastered' : (frag.status === 'study' ? 'Studying' : 'New');

            tr.innerHTML = `
                <td><span class="status-badge ${statusClass}" onclick="cycleFragmentStatus('${frag.id}')">${statusLabel}</span></td>
                <td contenteditable="true" onblur="updateFragmentName('${frag.id}', this.innerText)">${frag.name}</td>
                <td>${makeTimeInputHTML(frag.id, 'start', frag.start)}</td>
                <td>${makeTimeInputHTML(frag.id, 'end', frag.end)}</td>
                <td>
                    <span class="metric-pill">üìñ ${stats.phrases} Phr</span>
                    <span class="metric-pill">üîë ${stats.words} Wrd</span>
                </td>
                <td style="font-weight:700; color:#6366f1;">${timeStudied}</td>
                <td>
                    ${activeFragmentId === frag.id 
                        ? `<button class="frag-btn" onclick="stopFragmentLoop()" style="background:#ef4444">‚èπ Stop</button>`
                        : `<button class="frag-btn primary" onclick="playFragment('${frag.id}')">‚ñ∂ Focus</button>`
                    }
                </td>
                <td>
                    <button class="frag-btn-del" onclick="deleteFragment('${frag.id}')">‚úï</button>
                </td>
            `;
            tbody.appendChild(tr);
        });

        document.getElementById('total-time-studied').innerText = `Total Study: ${formatTime(totalSecs)}`;
    }

    function updateFragmentTime(id, type, value) {
        const frag = videoFragments.find(f => f.id === id);
        if (frag) {
            frag[type] = parseFloat(value);
            localStorage.setItem(STORAGE_KEY_FRAGMENTS, JSON.stringify(videoFragments));
            if (!document.activeElement.classList.contains('frag-input-qty')) {
                renderFragmentList(); 
            }
        }
    }

    function captureTimeForFragment(id, type) {
        if (!player) return;
        const current = player.getCurrentTime();
        updateFragmentTime(id, type, current);
        renderFragmentList(); 
    }

    function calculateFragmentStats(start, end) {
        let items = JSON.parse(localStorage.getItem(VOCAB_KEY) || '[]');
        let phrases = 0;
        let words = 0;

        const scan = (list) => {
            list.forEach(item => {
                if (item.isFolder && item.items) scan(item.items);
                else {
                    let matchesVideo = false;
                    if (item.source) {
                        if (item.source.videoId === YOUTUBE_ID) matchesVideo = true;
                        else if (!item.source.videoId && item.source.title === VIDEO_TITLE) matchesVideo = true;
                    }

                    if (matchesVideo) {
                        if (item.source.timestamp >= start && item.source.timestamp <= end) {
                            if (item.eng.includes(' ')) phrases++; else words++;
                        }
                    }
                }
            });
        };
        scan(items);
        return { phrases, words };
    }

    function addFragment() {
        if (!player) return;
        const current = player.getCurrentTime();
        
        const start = current;
        let end = current + 300; 
        if (player.getDuration && end > player.getDuration()) {
            end = player.getDuration();
        }
        
        const newFrag = {
            id: Date.now().toString(),
            name: `Manual Fragment ${videoFragments.length + 1}`,
            start: start,
            end: end,
            status: 'new',
            timeSpent: 0,
            type: 'manual' 
        };
        
        videoFragments.push(newFrag);
        localStorage.setItem(STORAGE_KEY_FRAGMENTS, JSON.stringify(videoFragments));
        renderFragmentList();
    }

   function playFragment(id) {
        const frag = videoFragments.find(f => f.id === id);
        if (!frag) return;
        
        activeFragmentId = id;
        localStorage.setItem('mdc_active_frag_' + YOUTUBE_ID, id);

        document.getElementById('fragment-modal').style.display = 'none';
        
        player.seekTo(frag.start);
        player.playVideo();
        
        if (frag.status === 'new') {
            frag.status = 'study';
            localStorage.setItem(STORAGE_KEY_FRAGMENTS, JSON.stringify(videoFragments));
        }
        renderFragmentList(); 
    }

   function stopFragmentLoop() {
        activeFragmentId = null;
        localStorage.removeItem('mdc_active_frag_' + YOUTUBE_ID);
        renderFragmentList();
    }

    function cycleFragmentStatus(id) {
        const frag = videoFragments.find(f => f.id === id);
        if (!frag) return;
        if (frag.status === 'new') frag.status = 'study';
        else if (frag.status === 'study') frag.status = 'master';
        else frag.status = 'new';
        
        localStorage.setItem(STORAGE_KEY_FRAGMENTS, JSON.stringify(videoFragments));
        renderFragmentList();
    }

    function updateFragmentName(id, name) {
        const frag = videoFragments.find(f => f.id === id);
        if (frag) {
            frag.name = name;
            localStorage.setItem(STORAGE_KEY_FRAGMENTS, JSON.stringify(videoFragments));
        }
    }

    function deleteFragment(id) {
        if(!confirm("Delete this fragment?")) return;
        videoFragments = videoFragments.filter(f => f.id !== id);
        if (activeFragmentId === id) activeFragmentId = null;
        localStorage.setItem(STORAGE_KEY_FRAGMENTS, JSON.stringify(videoFragments));
        renderFragmentList();
        highlightSavedFragments();
    }
    
    function deleteAllFragments() {
        if(videoFragments.length === 0) return;
        if(!confirm("‚ö†Ô∏è Are you sure you want to DELETE ALL fragments? This cannot be undone.")) return;
        
        videoFragments = [];
        activeFragmentId = null;
        localStorage.setItem(STORAGE_KEY_FRAGMENTS, JSON.stringify(videoFragments));
        renderFragmentList();
        highlightSavedFragments();
    }

    function formatTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}m ${s}s`;
    }
    
    function formatTimeShort(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s < 10 ? '0'+s : s}`;
    }

    function updateTimingSettings() {
        timeOffset = parseFloat(document.getElementById('input-time-offset').value) || 0;
        endPadding = parseFloat(document.getElementById('input-end-padding').value) || 0;
        localStorage.setItem(PREF_TIMING, JSON.stringify({ offset: timeOffset, padding: endPadding }));
    }

    function loadTimingPrefs() {
        const saved = localStorage.getItem(PREF_TIMING);
        if (saved) { const parsed = JSON.parse(saved); timeOffset = parseFloat(parsed.offset); endPadding = parseFloat(parsed.padding); }
        document.getElementById('input-time-offset').value = timeOffset; document.getElementById('input-end-padding').value = endPadding;
        const savedOffset = localStorage.getItem(PREF_OFFSET);
        if(savedOffset) { currentVerticalOffset = parseInt(savedOffset); document.getElementById('vertical-slider').value = currentVerticalOffset; }
    }
    
    function updateVerticalOffset(val) {
        currentVerticalOffset = parseInt(val); localStorage.setItem(PREF_OFFSET, currentVerticalOffset);
        const activeLine = document.querySelector('.line.active'); if(activeLine) scrollToActiveElement(activeLine);
    }
    
    function toggleMenu(menuId) {
        document.querySelectorAll('.popup-menu').forEach(m => { if(m.id !== menuId) m.classList.remove('active'); });
        document.getElementById(menuId).classList.toggle('active');
    }
    
    function loadPreferences() {
        const sSpeed = localStorage.getItem(PREF_SPEED);
        if(sSpeed) { currentPlaybackRate = parseFloat(sSpeed); document.getElementById('btn-speed').innerText = currentPlaybackRate + 'x'; }
        const sScroll = localStorage.getItem(PREF_SCROLL);
        if(sScroll !== null) { 
            autoScroll = (sScroll === 'true'); 
            const btn = document.getElementById('btn-autoscroll'); 
            btn.style.color = autoScroll ? '#6366f1' : 'white'; 
            btn.style.opacity = autoScroll ? '1' : '0.5';
            btn.innerText = autoScroll ? 'üîí' : 'üîì';
        }
        const sTrans = localStorage.getItem(PREF_TRANS);
        if(sTrans === 'true') { allVisible = true; document.getElementById('btn-toggle-trans').style.color = '#6366f1'; }
        loadTimingPrefs();
    }
    function cycleSpeed() {
        currentPlaybackRate = parseFloat((currentPlaybackRate - 0.1).toFixed(1));
        if (currentPlaybackRate < 0.6) currentPlaybackRate = 1.0;
        localStorage.setItem(PREF_SPEED, currentPlaybackRate);
        if(player && player.setPlaybackRate) player.setPlaybackRate(currentPlaybackRate);
        document.getElementById('btn-speed').innerText = currentPlaybackRate + 'x';
    }
    function toggleAutoScroll() { 
        autoScroll = !autoScroll; localStorage.setItem(PREF_SCROLL, autoScroll); 
        const btn = document.getElementById('btn-autoscroll'); 
        btn.style.color = autoScroll ? '#6366f1' : 'white'; 
        btn.style.opacity = autoScroll ? '1' : '0.5';
        btn.innerText = autoScroll ? 'üîí' : 'üîì';
    }
    
    function toggleAllTranslations() { 
        const container = document.querySelector('.dialogue-container');
        const activeLine = document.querySelector('.line.active');

        allVisible = !allVisible; 
        localStorage.setItem(PREF_TRANS, allVisible); 
        document.getElementById('btn-toggle-trans').style.color = allVisible ? '#6366f1' : 'white'; 
        
        if(container) container.style.scrollBehavior = 'auto';

        document.querySelectorAll('.spanish').forEach(span => { 
            span.classList.toggle('visible', allVisible); 
        }); 

        if (activeLine) {
            scrollToActiveElement(activeLine);
        }

        if(container) {
            setTimeout(() => { container.style.scrollBehavior = 'smooth'; }, 50);
        }
    }
    
    function toggleLoop() {
        isLooping = !isLooping; const btn = document.getElementById('btn-loop');
        if(isLooping) btn.classList.add('active-state'); else btn.classList.remove('active-state');
    }

    function toggleMirror() {
        isMirrorActive = !isMirrorActive; const btn = document.getElementById('btn-mirror');
        if(isMirrorActive) btn.classList.add('active-state'); else btn.classList.remove('active-state');
    }

    function initLazyObserver() {
        const options = { root: null, rootMargin: '200px', threshold: 0.1 };
        
        lineObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const line = entry.target;
                    if (!line.classList.contains('hydrated')) {
                        hydrateLine(line);
                        line.classList.add('hydrated');
                    }
                    observer.unobserve(line);
                }
            });
        }, options);

        document.querySelectorAll('.line').forEach(line => lineObserver.observe(line));
    }

    function hydrateLine(lineElement) {
        const engDiv = lineElement.querySelector('.english');
        const espDiv = lineElement.querySelector('.spanish');
        
        let engIndex = parseInt(lineElement.dataset.wordStart || 0);

        if (engDiv) {
            const rawText = engDiv.textContent || "";
            const words = rawText.trim().split(/\s+/);
                engDiv.innerHTML = words.map(word => {
                if(!word) return '';
                const span = `<span class="word-interactive english-word" data-lang="en" data-idx="${engIndex}" 
                    onmousedown="startPress(this)" 
                    ontouchstart="startPress(this)" 
                    onmouseup="endPress(this, event)" 
                    ontouchend="endPress(this, event)"
                    onclick="handleShortClick(this, event)"
                    onmouseenter="handleHoverStart(this)" 
                    onmouseleave="handleHoverEnd()">${word}</span> `;
                engIndex++; 
                return span;
            }).join('');
        }

        if (espDiv) {
            if(allVisible) espDiv.classList.add('visible');
            const rawText = espDiv.textContent || "";
            const words = rawText.trim().split(/\s+/);
            espDiv.innerHTML = words.map(word => {
                if(!word) return '';
                return `<span class="spanish-word">${word}</span> `;
            }).join('');
        }
        updateAllWordStates(); 
    }

    function updateAllWordStates() {
    const vocab = JSON.parse(localStorage.getItem(VOCAB_KEY) || '[]');
    const savedWordsSet = new Set();
    const savedPhrases = [];

    const collect = (list) => {
        list.forEach(item => {
            if (item.isFolder && item.items) return collect(item.items);
            if (!item.eng) return;
            const clean = sanitizeText(item.eng).toLowerCase();
            if (clean.includes(' ')) {
                savedPhrases.push(clean);
            } else if (clean) {
                savedWordsSet.add(clean);
            }
        });
    };
    collect(vocab);

    savedPhrases.sort((a, b) => b.split(/\s+/).length - a.split(/\s+/).length || b.length - a.length);

    document.querySelectorAll('.english-word').forEach(el => {
        if (el.dataset.userSelected !== "true") {
            el.classList.remove('saved-word', 'phrase-word');
            delete el.dataset.phraseParent;
        }
    });

    document.querySelectorAll('.line').forEach(line => {
        const wordsEls = Array.from(line.querySelectorAll('.english-word'));
        const wordsText = wordsEls.map(el => sanitizeText(el.innerText).toLowerCase());

        savedPhrases.forEach(phrase => {
            const phraseWords = phrase.split(/\s+/).filter(Boolean);
            if (phraseWords.length === 0) return;

            for (let i = 0; i <= wordsText.length - phraseWords.length; i++) {
                let match = true;
                for (let j = 0; j < phraseWords.length; j++) {
                    if (wordsText[i + j] !== phraseWords[j]) {
                        match = false;
                        break;
                    }
                }
                
                if (match) {
                    for (let j = 0; j < phraseWords.length; j++) {
                        const el = wordsEls[i + j];
                        if (el && el.dataset.userSelected !== "true" && !el.dataset.phraseParent) {
                            el.classList.add('phrase-word');
                            el.dataset.phraseParent = phrase;
                        }
                    }
                }
            }
        });
    });

    document.querySelectorAll('.english-word').forEach(el => {
        if (el.dataset.userSelected === "true") return;
        const clean = sanitizeText(el.innerText).toLowerCase();
        if (savedWordsSet.has(clean)) {
            el.classList.add('saved-word');
        }
    });

    updateNavigationIndex();
    }

    function updateNavigationIndex() {
        const allSavedElements = document.querySelectorAll('.english-word.saved-word, .english-word.phrase-word');
        const uniqueSet = new Set();
        
        allSavedElements.forEach(el => {
            uniqueSet.add(sanitizeText(el.innerText).toLowerCase());
        });
        
        currentWordStats.uniqueTotal = uniqueSet.size;

        const lines = document.querySelectorAll('.line');
        const uniqueTimes = new Set();
        lines.forEach(line => {
            if (line.querySelector('.saved-word') || line.querySelector('.phrase-word')) {
                uniqueTimes.add(parseFloat(line.dataset.start));
            }
        });
        savedTimestamps = Array.from(uniqueTimes).sort((a, b) => a - b);
        
        renderCounterUI();
    }

    function renderCounterUI() {
        const btnClear = document.getElementById('btn-clear');
        const counter = document.getElementById('nav-counter');
        
        counter.innerText = `${currentWordStats.occurrences} | ${currentWordStats.uniqueTotal}`;
        
        if (currentWordStats.uniqueTotal > 0) {
            btnClear.classList.remove('disabled');
            counter.style.color = "#f472b6"; 
            counter.style.fontWeight = "800";
            counter.style.letterSpacing = "1px";
        } else {
            btnClear.classList.add('disabled');
            counter.style.color = "#9ca3af";
        }
    }

    function startPress(el) {
        isLongPressHandled = false; 
        pressTimer = setTimeout(() => {
            handleLongPressLogic(el); 
            isLongPressHandled = true; 
        }, 500); 
    }

    function endPress(el, e) {
        clearTimeout(pressTimer);
        if(e.type === 'touchend' && isLongPressHandled) {
            e.preventDefault(); 
        }
    }

    function handleShortClick(el, event) {
        if (isLongPressHandled) return; 

        if (el.dataset.userSelected === "true") {
            clearManualSelection();
            return;
        }

        const rawText = el.innerText.replace(/[^a-zA-Z0-9]/g, "");
        translateWordForBar(rawText);
        
        if (document.querySelector('.english-word[data-user-selected="true"]')) {
             clearManualSelection();
        }

        toggleWordSelection(el, event); 
    }

    function clearManualSelection() {
        document.querySelectorAll('.english-word[data-user-selected="true"]').forEach(el => {
            el.classList.remove('phrase-word');
            delete el.dataset.userSelected;
        });
        pendingPhraseStartIdx = null;
    }

    function handleLongPressLogic(el) {
        if (navigator.vibrate) navigator.vibrate(50); 

        if (el.dataset.phraseParent) {
            clearManualSelection(); 
            deletePhraseFromMemory(el.dataset.phraseParent);
            return;
        }

        const currentIdx = parseInt(el.dataset.idx);

        if (pendingPhraseStartIdx === null) {
            clearManualSelection(); 

            el.classList.add('phrase-word');
            el.dataset.userSelected = "true";
            pendingPhraseStartIdx = currentIdx;
        } 
        else {
            const startEl = document.querySelector(`.english-word[data-idx="${pendingPhraseStartIdx}"]`);
            const startLine = startEl ? startEl.closest('.line') : null;
            const endLine = el.closest('.line');

            if (!startLine || !endLine || startLine !== endLine) {
                if (navigator.vibrate) navigator.vibrate([50, 50]); 
                clearManualSelection();
                return;
            }

            const start = Math.min(pendingPhraseStartIdx, currentIdx);
            const end = Math.max(pendingPhraseStartIdx, currentIdx);
            const distance = end - start;

            if (distance > 12) {
                if (navigator.vibrate) navigator.vibrate([50, 50]); 
                clearManualSelection();
                return;
            }

            const allWords = Array.from(document.querySelectorAll('.english-word'));
            const wordsInRange = [];
            let pathBlocked = false;

            for (let i = start; i <= end; i++) {
                const wordEl = allWords.find(w => parseInt(w.dataset.idx) === i);
                if (wordEl) {
                    if (wordEl.dataset.phraseParent) {
                        pathBlocked = true;
                        break; 
                    }
                    wordsInRange.push(wordEl);
                }
            }

            if (pathBlocked) {
                if (navigator.vibrate) navigator.vibrate([50, 50, 50]); 
                clearManualSelection(); 
            } else {
                wordsInRange.forEach(w => {
                    w.classList.add('phrase-word');
                    w.dataset.userSelected = "true";
                });
                pendingPhraseStartIdx = null; 
            }
        }
    }

    function deletePhraseFromMemory(phraseText) {
        let items = JSON.parse(localStorage.getItem(VOCAB_KEY) || '[]');
        const cleanPhrase = phraseText.toLowerCase();

        items = items.filter(i => {
            if (!i.isFolder && i.eng && sanitizeText(i.eng).toLowerCase() === cleanPhrase) return false;
            return true;
        });

        items.forEach(folder => {
            if (folder.isFolder && folder.items) {
                folder.items = folder.items.filter(sub => sanitizeText(sub.eng).toLowerCase() !== cleanPhrase);
            }
        });

        localStorage.setItem(VOCAB_KEY, JSON.stringify(items));
        updateAllWordStates(); 
    }

    function toggleWordSelection(element, event) {
        event.stopPropagation(); 
        const lang = element.dataset.lang; 
        if (lang !== 'en') return; 

        const rawText = element.innerText;
        const cleanText = sanitizeText(rawText);
        if(!cleanText) return;

        lastSelectedWordText = cleanText;

        let count = 0;
        document.querySelectorAll('.english-word').forEach(el => {
            if (sanitizeText(el.innerText).toLowerCase() === cleanText.toLowerCase()) {
                count++;
            }
        });
        currentWordStats.occurrences = count; 

        let vocab = JSON.parse(localStorage.getItem(VOCAB_KEY) || '[]');
        let found = false;
        
        if(vocab.some(i => !i.isFolder && sanitizeText(i.eng).toLowerCase() === cleanText.toLowerCase())) found = true;
        if(!found) {
            vocab.forEach(f => {
                if(f.isFolder && f.items.some(sub => sanitizeText(sub.eng).toLowerCase() === cleanText.toLowerCase())) found = true;
            });
        }

        if (found) {
            vocab = vocab.filter(i => i.isFolder || sanitizeText(i.eng).toLowerCase() !== cleanText.toLowerCase());
            vocab.forEach(f => {
                if(f.isFolder) {
                    f.items = f.items.filter(sub => sanitizeText(sub.eng).toLowerCase() !== cleanText.toLowerCase());
                }
            });
            localStorage.setItem(VOCAB_KEY, JSON.stringify(vocab));
            updateAllWordStates(); 
            
        } else {
            const line = element.closest('.line');
           const contextSource = { 
                type: 'youtube', 
                videoId: YOUTUBE_ID, 
                title: VIDEO_TITLE, 
                timestamp: parseFloat(line.dataset.start),
                timestampEnd: parseFloat(line.dataset.end), 
                context: line.querySelector('.english').innerText,
                contextEsp: line.querySelector('.spanish').innerText 
            };

            const newItem = { 
                id: Date.now() + Math.random(), 
                isFolder: false, 
                eng: cleanText, 
                esp: "", 
                isHighlighted: false, 
                source: contextSource, 
                dateAdded: Date.now() 
            };
            
            const targetName = VIDEO_TITLE || "Saved from Studio";
            let targetFolder = vocab.find(i => i.isFolder && i.name === targetName);
            
            if(targetFolder) {
                targetFolder.items.unshift(newItem);
                vocab = vocab.filter(i => i.id !== targetFolder.id);
                vocab.unshift(targetFolder);
            } else {
                const newFolder = { id: Date.now(), isFolder: true, name: targetName, items: [newItem] };
                vocab.unshift(newFolder);
            }
            
            localStorage.setItem(VOCAB_KEY, JSON.stringify(vocab));
            updateAllWordStates(); 
        }
    }
    
    function speakText(text, onStart, onEnd) { 
        if (!('speechSynthesis' in window)) {
            console.warn("Tu navegador no soporta s√≠ntesis de voz.");
            return;
        }
        window.speechSynthesis.cancel(); 
        const utter = new SpeechSynthesisUtterance(text); 
        utter.lang = TTS_LANG; 
        utter.rate = TTS_RATE; 
        if(onStart) utter.onstart = onStart; 
        if(onEnd) utter.onend = onEnd; 
        
        if (speechSynthesis.getVoices().length === 0) {
            speechSynthesis.onvoiceschanged = () => {
                const voices = speechSynthesis.getVoices();
                const enVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
                if (enVoice) utter.voice = enVoice;
                speechSynthesis.speak(utter);
            };
        } else {
            const voices = speechSynthesis.getVoices();
            const enVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
            if (enVoice) utter.voice = enVoice;
            speechSynthesis.speak(utter);
        }
    }

    function speakActiveOrSelected() { 
        // L√≥gica actualizada: Pronunciar lo que est√° en la p√≠ldora
        if (currentPillText) {
            speakText(currentPillText);
            return;
        }
        
        // Fallback: Si no hay nada en la p√≠ldora, intentar con la √∫ltima selecci√≥n
        if (lastSelectedWordText) {
            speakText(lastSelectedWordText);
            return;
        }
        
        // √öltimo recurso: Leer la l√≠nea activa
        const activeLine = document.querySelector('.line.active .english');
        if (activeLine) {
            speakText(activeLine.innerText);
        }
    }

    async function translateWordForBar(text) {
        // Actualizamos la variable global con la palabra actual
        currentPillText = text; 

        const display = document.getElementById('trans-result-box');
        if(!text) { display.style.display = 'none'; return; }
        
        display.style.display = 'block';
        display.innerText = "loading...";

        try {
            const res = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=es&dt=t&q=${encodeURIComponent(text)}`);
            const data = await res.json();
            let result = "Error";
            if (data && data[0] && data[0][0]) {
                result = data[0][0][0];
            }
            display.innerText = result;
        } catch (e) {
            display.innerText = "Error";
        }
    }

    function clearAllWords() { 
        if (currentWordStats.uniqueTotal === 0) {
            return alert("No hay palabras guardadas en este video.");
        }

        if(!confirm('‚ö†Ô∏è ¬øEst√°s seguro? \n\nEsto eliminar√° TODAS las palabras y frases guardadas asociadas a ESTE VIDEO (ID: ' + YOUTUBE_ID + ').')) return; 
        
        let items = JSON.parse(localStorage.getItem(VOCAB_KEY) || '[]');
        let countDeleted = 0;

        const belongsToCurrentVideo = (item) => {
            if (item.source && item.source.videoId === YOUTUBE_ID) return true;
            if (item.source && !item.source.videoId && item.source.title === VIDEO_TITLE) return true;
            return false;
        };

        items = items.filter(item => {
            if (item.isFolder && item.items) {
                const initialLength = item.items.length;
                item.items = item.items.filter(sub => !belongsToCurrentVideo(sub));
                countDeleted += (initialLength - item.items.length);
                return true; 
            }
            if (belongsToCurrentVideo(item)) {
                countDeleted++;
                return false; 
            }
            return true;
        });

        localStorage.setItem(VOCAB_KEY, JSON.stringify(items));
        
        currentWordStats = { occurrences: "-", uniqueTotal: 0 }; 
        updateAllWordStates(); 
        translateWordForBar(""); 
        renderCounterUI(); 
        
        alert(`‚úÖ Se eliminaron ${countDeleted} elementos de este video.`);
    }
    
  function attachButtonEvents() {
        document.querySelectorAll('.playBtn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); 
                const line = btn.closest('.line');
                const start = parseFloat(line.dataset.start) - timeOffset;
                let rawEnd = parseFloat(line.dataset.end);
                
                
                const nextLine = line.nextElementSibling;
                if (nextLine && nextLine.classList.contains('line')) {
                   const nextStart = parseFloat(nextLine.dataset.start);
                    if (rawEnd > nextStart) {
                        rawEnd = nextStart; 
                    }
                }

                
                const end = rawEnd + endPadding;
                if (btn.dataset.state === 'playing') { player.pauseVideo(); isSegmentPlaying = false; resetButtons(); return; }
                resetButtons(); 
                window.speechSynthesis.cancel(); 
                document.querySelectorAll('.line.active').forEach(l => l.classList.remove('active'));
                scrollEnabled = false; 
                isSegmentPlaying = true; 
                segmentEndTime = end;
                player.seekTo(Math.max(0, start), true); 
                player.playVideo(); 
                player.setPlaybackRate(currentPlaybackRate);
                btn.textContent = "‚èπ"; // Cuadrado de Stop
                btn.dataset.state = 'playing'; 
                line.classList.add('active');
            });
        });
        
        document.querySelectorAll('.speakBtn').forEach(btn => {
             btn.addEventListener('click', (e) => {
                e.stopPropagation(); const line = btn.closest('.line'); const text = line.querySelector('.english').innerText;
                if (btn.dataset.state === 'speaking') { window.speechSynthesis.cancel(); resetButtons(); return; }
                resetButtons(); window.speechSynthesis.cancel(); player.pauseVideo();
                speakText(text, () => { btn.textContent = "Stop"; btn.dataset.state = 'speaking'; document.querySelectorAll('.line.active').forEach(l => l.classList.remove('active')); line.classList.add('active'); }, () => { resetButtons(); });
            });
        });
    }

    function saveLineToVocab(btn) {
        const line = btn.closest('.line'); 
        let items = JSON.parse(localStorage.getItem(VOCAB_KEY) || '[]');
        
        const manualSelection = Array.from(line.querySelectorAll('.english-word.phrase-word')).filter(el => el.dataset.userSelected === "true");
        
        let textToSave = "";
        
        if (manualSelection.length > 0) {
            manualSelection.sort((a,b) => parseInt(a.dataset.idx) - parseInt(b.dataset.idx));
            textToSave = manualSelection.map(el => sanitizeText(el.innerText)).join(" ");
        } else {
            textToSave = sanitizeText(line.querySelector('.english').innerText);
        }

        if (!textToSave) return;

        const isDuplicate = (textToCheck) => {
            const cleanCheck = sanitizeText(textToCheck).toLowerCase();
            for (let item of items) {
                if (!item.isFolder && item.eng && sanitizeText(item.eng).toLowerCase() === cleanCheck) return true;
                if (item.isFolder && item.items) { for (let sub of item.items) { if (sub.eng && sanitizeText(sub.eng).toLowerCase() === cleanCheck) return true; } }
            }
            return false;
        };

        if (!isDuplicate(textToSave)) {
            const contextSource = { 
                type: 'youtube', 
                videoId: YOUTUBE_ID, 
                title: VIDEO_TITLE, 
                timestamp: parseFloat(line.dataset.start), 
                context: line.querySelector('.english').innerText,
                contextEsp: line.querySelector('.spanish').innerText 
            };

            const newItem = { 
                id: Date.now() + Math.random(), 
                isFolder: false, 
                eng: textToSave, 
                esp: "", 
                isHighlighted: false, 
                source: contextSource, 
                dateAdded: Date.now() 
            };
            
            const targetNameRaw = VIDEO_TITLE || "Saved from Studio";
            const cleanTargetName = targetNameRaw.trim(); 
            let targetFolder = items.find(i => i.isFolder === true && i.name.trim().toLowerCase() === cleanTargetName.toLowerCase());
            
            if (targetFolder) { targetFolder.items.unshift(newItem); items = items.filter(i => i.id !== targetFolder.id); items.unshift(targetFolder); } 
            else { const newFolder = { id: Date.now() + 1, isFolder: true, name: cleanTargetName, items: [newItem] }; items.unshift(newFolder); }
            
            localStorage.setItem(VOCAB_KEY, JSON.stringify(items));
            
            const originalText = btn.innerHTML; btn.innerHTML = "‚úì"; btn.style.backgroundColor = "#10b981"; btn.style.color = "white";
            setTimeout(() => { btn.innerHTML = originalText; btn.style.backgroundColor = ""; btn.style.color = ""; }, 1000);
            
            // CLEAN UP MANUAL SELECTION
            manualSelection.forEach(el => {
                delete el.dataset.userSelected;
                el.classList.remove('phrase-word'); // Remove Amber immediately
            });
            
            updateAllWordStates(); 
        } else { 
            alert("Esta frase ya existe en tu vocabulario."); 
        }
    }
    
    function resetButtons() { 
    document.querySelectorAll('.playBtn').forEach(b => { 
        b.textContent = "‚ñ∂"; // Vuelta al tri√°ngulo
        b.removeAttribute('data-state'); 
    }); 
    document.querySelectorAll('.speakBtn').forEach(b => { 
        b.textContent = "Speak"; 
        b.removeAttribute('data-state'); 
    }); 
}
    
    document.addEventListener('click', function(e) { 
        const timingMenu = document.getElementById('timing-menu'); const timingBtn = document.getElementById('btn-timing'); 
        const posMenu = document.getElementById('position-menu'); const posBtn = document.getElementById('btn-position');
        if (!timingMenu.contains(e.target) && !timingBtn.contains(e.target) && timingMenu.classList.contains('active')) { toggleMenu('timing-menu'); }
        if (!posMenu.contains(e.target) && !posBtn.contains(e.target) && posMenu.classList.contains('active')) { toggleMenu('position-menu'); }
    });

    window.addEventListener('message', function(event) {
        if (event.data === 'FORCE_PAUSE') {
            if (player && typeof player.pauseVideo === 'function') { player.pauseVideo(); }
        }
    });

    const NEXUS_URL = 'https://paradisonetworx.com/echo2';

function openNexus(mode = 'ALL') {
    // 1. VALIDACI√ìN PARA MODO FOCUS
    if (mode === 'FOCUS') {
        if (!activeFragmentId) {
            alert("‚ö†Ô∏è No Active Fragment selected!\n\nPlease click '‚ñ∂ Focus' on one of the fragments in the list below first, then click this button.");
            return;
        }
    }

    const portal = document.getElementById('nexus-portal');
    const frame = document.getElementById('nexus-frame');
    
    // Ocultamos el modal de fragmentos si estaba abierto
    document.getElementById('fragment-modal').style.display = 'none';
    
    portal.style.display = 'block';
    
    frame.onload = function() {
        let rawData = localStorage.getItem(VOCAB_KEY) || '[]';
        let vocabData = JSON.parse(rawData);

        // Preparaci√≥n de datos (Sanitizaci√≥n b√°sica)
        const modifiedData = vocabData.map(folder => {
            if(folder.isFolder && folder.items) {
                // Devolvemos los items tal cual, sin reemplazar espacios, para mantener la integridad
                return folder; 
            }
            return folder;
        });

        // --- L√ìGICA DE FILTRO ---
        let filterToSend = null;

        if (mode === 'FOCUS' && activeFragmentId) {
            const frag = videoFragments.find(f => f.id === activeFragmentId);
            if (frag) {
                filterToSend = {
                    videoId: YOUTUBE_ID,
                    start: frag.start,
                    end: frag.end,
                    name: frag.name
                };
            }
        }

        // ENVIAMOS DATOS + CONFIGURACI√ìN DE LOOPS
        frame.contentWindow.postMessage({
            action: 'IMPORT_DATA',
            data: JSON.stringify(modifiedData),
            filter: filterToSend,
            // AQU√ç AGREGAMOS LA CONFIGURACI√ìN QUE PEDISTE:
            settings: {
                autoplay: true,
                loopLimit: 5,   // Repetir 5 veces
                autoAdvance: false // Detenerse (no avanzar) si no hay click
            }
        }, '*');
    };

    frame.src = NEXUS_URL;
    if(player && typeof player.pauseVideo === 'function') { player.pauseVideo(); }
}

   function closeNexus() {
        const portal = document.getElementById('nexus-portal');
        const frame = document.getElementById('nexus-frame');
        portal.style.display = 'none';
        frame.src = '';
        
        // FIX: Forzar repintado al volver para asegurar que todo se vea bien
        updateAllWordStates(); 
    }

async function copyHistoryData(e, id, btnElement) {
        e.stopPropagation(); 
        
        const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
        const item = history.find(i => i.id === id);
        
        if(!item) return alert("Error: No se encontraron datos.");

        try {
            const dataToCopy = JSON.stringify(item);
            await navigator.clipboard.writeText(dataToCopy);
            
            const originalText = btnElement.innerText;
            btnElement.innerText = "‚úÖ"; 
            btnElement.style.opacity = "1";
            
            setTimeout(() => {
                btnElement.innerText = originalText;
                btnElement.style.opacity = "";
            }, 1000);
            
        } catch (err) {
            console.error('Error al copiar:', err);
            alert("No se pudo copiar al portapapeles.");
        }
    }
</script>

<script>
(function() {
    const VOCAB_KEY = 'mdc_vocab_list';
    let isTranslating = false; // Bandera para evitar bucles infinitos

    // 1. Interceptar el guardado local (Misma pesta√±a)
    const originalSetItem = localStorage.setItem;
   
    localStorage.setItem = function(key, value) {
        // Guardado normal
        originalSetItem.apply(this, arguments);
        
        // Si es nuestra clave y no estamos traduciendo, revisamos
        if (key === VOCAB_KEY && !isTranslating) {
            setTimeout(checkAndFixTranslations, 100);
        }
    };

    // 2. Escuchar guardados de OTRAS pesta√±as
    window.addEventListener('storage', (e) => {
        if (e.key === VOCAB_KEY && !isTranslating) {
            checkAndFixTranslations();
        }
    });

    // 3. Revisar al cargar la p√°gina
    document.addEventListener('DOMContentLoaded', checkAndFixTranslations);

    // --- L√ìGICA DE TRADUCCI√ìN ---
    async function checkAndFixTranslations() {
        if (isTranslating) return; // Si ya estoy trabajando, no interrumpas
        
        isTranslating = true; // Bloqueamos al inicio
        
        try {
            const raw = localStorage.getItem(VOCAB_KEY);
            if (!raw) return;
            
            let items;
            try {
                items = JSON.parse(raw);
            } catch (e) {
                console.error("ü§ñ MDC Translator: Error al parsear JSON:", e);
                return;
            }
            
            let updated = false;
            
            // Funci√≥n auxiliar: conecta con Google Translate
            const translate = async (text) => {
                try {
                    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=es&dt=t&q=${encodeURIComponent(text)}`;
                    const res = await fetch(url);
                    if (!res.ok) {
                        throw new Error(`HTTP error! status: ${res.status}`);
                    }
                    const data = await res.json();
                    return (data && data[0]) ? data[0].map(s => s[0]).join('') : null;
                } catch (e) {
                    console.error("ü§ñ MDC Translator: Error en traducci√≥n:", e);
                    return null;
                }
            };
            
            // Escaneo recursivo
            const scanItems = async (list) => {
                for (let item of list) {
                    if (item.isFolder) {
                        await scanItems(item.items);
                    } else {
                        // CONDICI√ìN: Hay ingl√©s PERO el espa√±ol est√° vac√≠o o no existe
                        if (item.eng && (!item.esp || item.esp.trim() === "")) {
                            const translation = await translate(item.eng);
                            if (translation) {
                                item.esp = translation
                                    .replace(/['`‚Äò¬¥]/g, "‚Äô")
                                    .replace(/[^a-zA-Z0-9\u00C0-\u017F\s‚Äô]/g, "");
                                updated = true;
                            }
                        }
                    }
                }
            };
            
            await scanItems(items);
            
            if (updated) {
                console.log("ü§ñ MDC Translator: Nuevas palabras detectadas y traducidas.");
                
                // Guardamos usando la funci√≥n ORIGINAL para evitar bucle
                originalSetItem.call(localStorage, VOCAB_KEY, JSON.stringify(items));
                
                // Notificamos a la p√°gina actual para que se refresque
                refreshCurrentPage(items);
            }
        } finally {
            isTranslating = false; // SIEMPRE liberamos la bandera, incluso si hay error
        }
    }

    // Funci√≥n para actualizar la interfaz visual sin recargar la p√°gina
    function refreshCurrentPage(items) {
        // Intenta actualizar el reproductor
        if (typeof updateAllWordStates === 'function') updateAllWordStates();
        
        // Intenta actualizar la lista de vocabulario
        if (typeof loadVocab === 'function') loadVocab();
        else if (typeof renderList === 'function') renderList(items);
    }
})();

function highlightSavedFragments() {

    const lines = document.querySelectorAll('.line');

    

    // 1. Limpieza inicial (Volvemos al estado 'limpio' del CSS)

    lines.forEach(l => {

        l.style.borderLeftColor = ''; 

        l.style.boxShadow = ''; 

        l.style.backgroundColor = ''; 

    });



    if (!videoFragments || videoFragments.length === 0) return;



    // 2. Paleta de colores

    const palette = [

        '#FACC15', // Amarillo

        '#4ADE80', // Verde

        '#22D3EE', // Cian

        '#A78BFA', // Violeta

        '#F472B6', // Rosa

        '#FB7185', // Coral

        '#FB923C', // Naranja

        '#94A3B8'  // Gris

    ];



    // 3. Iteramos L√çNEA por L√çNEA (Enfoque m√°s robusto para solapamientos)

    lines.forEach(line => {

        const lStart = parseFloat(line.dataset.start);

        const lEnd = parseFloat(line.dataset.end);

        

        // Buscamos TODOS los fragmentos a los que pertenece esta l√≠nea

        // (Usamos la l√≥gica estricta de finalizaci√≥n que arreglamos antes)

        const activeFrags = videoFragments.filter(frag => {

            // Calculamos el √≠ndice para saber su color original (para que no cambie si borras otros)

            frag._colorIndex = videoFragments.indexOf(frag); 

            return (lStart >= frag.start && lEnd <= (frag.end + 0.05));

        });



        // Si no pertenece a ninguno, pasamos a la siguiente

        if (activeFrags.length === 0) return;



        // 4. Si hay coincidencias, construimos las bandas

        // Limitamos a 4 por seguridad visual (aunque el c√≥digo aguanta m√°s)

        const visibleFrags = activeFrags.slice(0, 4);

        

        let shadowString = [];

        let accumulatedWidth = 0;

        const stripeWidth = 5; // Ancho de cada banda en p√≠xeles



        visibleFrags.forEach((frag) => {

            const color = palette[frag._colorIndex % palette.length];

            

            // Calculamos la posici√≥n de la sombra para que se apilen

            // Capa 1: 5px, Capa 2: 10px, Capa 3: 15px...

            accumulatedWidth += stripeWidth;

            

            // Truco CSS: inset Xpx 0 0 0 Color

            // Las sombras se apilan una DETR√ÅS de otra. La primera (m√°s peque√±a) tapa a la segunda.

            shadowString.push(`inset ${accumulatedWidth}px 0 0 0 ${color}`);

        });



        // 5. Aplicamos los estilos finales

        // Quitamos el borde blanco por defecto para que las bandas empiecen desde el borde real

        line.style.borderLeftColor = 'transparent';

        

        // Aplicamos la pila de sombras generada

        line.style.boxShadow = shadowString.join(', ');

        

        // Aplicamos un fondo sutil del color del fragmento M√ÅS PEQUE√ëO (el m√°s espec√≠fico)

        // Ordenamos por duraci√≥n para encontrar el m√°s corto

        const specificFrag = visibleFrags.sort((a,b) => (a.end - a.start) - (b.end - b.start))[0];

        const specificColor = palette[specificFrag._colorIndex % palette.length];

        line.style.backgroundColor = specificColor + '15'; // 15 = Transparencia muy baja

    });

}
</script>
    
</body>
</html>
