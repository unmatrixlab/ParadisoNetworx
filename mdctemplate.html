<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>MDC ENG - Video Learning</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
Â  :root {
Â  Â  --primary: #4f46e5; Â  Â  Â  /* Ãndigo profesional */
Â  Â  --primary-hover: #4338ca;
Â  Â  --accent: #ec4899; Â  Â  Â  Â /* Rosa para destaques */
Â  Â  --bg-body: #f3f4f6;
Â  Â  --card-bg: #ffffff;
Â  Â  --text-main: #1f2937;
Â  Â  --text-sec: #6b7280;
Â  Â  --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
Â  Â  --radius: 12px;
Â  Â  --header-height: 50px; Â  Â /* Altura fija para cÃ¡lculos */
Â  }

Â  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

Â  body {
Â  Â  margin: 0;
Â  Â  font-family: 'Inter', sans-serif;
Â  Â  background: var(--bg-body);
Â  Â  color: var(--text-main);
Â  Â  padding-top: var(--header-height); /* Espacio para el header fijo */
Â  }

Â  /* ====== HEADER MEJORADO (Estilo App) ====== */
Â  #mdc-header {
Â  Â  position: fixed;
Â  Â  top: 0; left: 0; width: 100%;
Â  Â  height: var(--header-height);
Â  Â  background: rgba(31, 41, 55, 0.95); /* Oscuro casi opaco */
Â  Â  backdrop-filter: blur(10px); Â  Â  Â  Â /* Efecto vidrio */
Â  Â  color: white;
Â  Â  z-index: 1000;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  Â  border-bottom: 1px solid rgba(255,255,255,0.1);
Â  Â  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
Â  }
Â  #mdc-header a {
Â  Â  color: white;
Â  Â  text-decoration: none;
Â  Â  font-weight: 700;
Â  Â  font-size: 16px;
Â  Â  letter-spacing: 0.5px;
Â  }

Â  /* ====== CONTENEDOR PRINCIPAL ====== */
Â  .page-max-width {
Â  Â  max-width: 600px;
Â  Â  margin: 0 auto;
Â  Â  width: 100%;
Â  Â  position: relative;
Â  }

Â  /* ====== VIDEO STICKY (Optimizado) ====== */
Â  .video-wrapper {
Â  Â  position: sticky;
Â  Â  top: var(--header-height); /* Se pega justo debajo del header */
Â  Â  width: 100%;
Â  Â  background: #000;
Â  Â  z-index: 500;
Â  Â  box-shadow: var(--shadow);
Â  }
Â  .video-inner {
Â  Â  position: relative;
Â  Â  padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
Â  Â  height: 0;
Â  Â  overflow: hidden;
Â  }
Â  .video-inner iframe {
Â  Â  position: absolute;
Â  Â  top: 0; left: 0;
Â  Â  width: 100%; height: 100%;
Â  Â  border: 0;
Â  }

Â  /* ====== LISTA DE DIÃLOGOS ====== */
Â  .dialogue-container {
Â  Â  padding: 20px 15px 80px 15px; /* Padding bottom extra para botÃ³n flotante */
Â  }

Â  .line {
Â  Â  background: var(--card-bg);
Â  Â  border-radius: var(--radius);
Â  Â  padding: 18px;
Â  Â  margin-bottom: 16px;
Â  Â  box-shadow: var(--shadow);
Â  Â  border-left: 4px solid transparent;
Â  Â  transition: transform 0.2s, box-shadow 0.2s, background-color 0.3s;
Â  }

Â  /* Estado Activo */
Â  .line.active {
Â  Â  border-left-color: var(--primary);
Â  Â  background-color: #eef2ff; /* Azul muy suave */
Â  Â  transform: scale(1.02);
Â  Â  box-shadow: 0 10px 15px -3px rgba(79, 70, 229, 0.2);
Â  }

Â  .line-content {
Â  Â  display: flex;
Â  Â  gap: 15px;
Â  Â  align-items: flex-start;
Â  }

Â  /* Textos */
Â  .text-block {
Â  Â  flex: 1;
Â  Â  cursor: pointer;
Â  }
Â  .english {
Â  Â  font-size: 1.05rem;
Â  Â  font-weight: 600;
Â  Â  line-height: 1.5;
Â  Â  color: var(--text-main);
Â  Â  margin-bottom: 6px;
Â  }
Â  .spanish {
Â  Â  font-size: 0.95rem;
Â  Â  color: var(--text-sec);
Â  Â  border-top: 1px solid #eee;
Â  Â  padding-top: 6px;
Â  Â  display: none; /* Oculto por defecto */
Â  Â  line-height: 1.4;
Â  }
Â  .spanish.visible {
Â  Â  display: block;
Â  Â  animation: fadeIn 0.3s ease;
Â  }

Â  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

Â  /* Botones de LÃ­nea */
Â  .controls {
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  gap: 8px;
Â  Â  min-width: 80px;
Â  }

Â  .btn {
Â  Â  border: none;
Â  Â  border-radius: 8px;
Â  Â  padding: 8px 0;
Â  Â  font-size: 13px;
Â  Â  font-weight: 600;
Â  Â  cursor: pointer;
Â  Â  transition: all 0.2s;
Â  Â  text-transform: uppercase;
Â  Â  letter-spacing: 0.5px;
Â  Â  width: 100%;
Â  }

Â  .playBtn {
Â  Â  background-color: var(--primary);
Â  Â  color: white;
Â  }
Â  .playBtn:hover { background-color: var(--primary-hover); }
Â Â 
Â  /* Estado Reproduciendo (Rojo Stop) */
Â  .playBtn[data-state="playing"] {
Â  Â  background-color: #ef4444;
Â  Â  animation: pulse 1.5s infinite;
Â  }

Â  .speakBtn {
Â  Â  background-color: #e5e7eb;
Â  Â  color: var(--text-main);
Â  }
Â  .speakBtn:hover { background-color: #d1d5db; }
Â Â 
Â  /* Estado Hablando */
Â  .speakBtn[data-state="speaking"] {
Â  Â  background-color: var(--accent);
Â  Â  color: white;
Â  }

Â  /* ====== BOTÃ“N FLOTANTE (Global Toggle) ====== */
Â  .fab-toggle {
Â  Â  position: fixed;
Â  Â  bottom: 20px;
Â  Â  right: 20px;
Â  Â  width: 56px;
Â  Â  height: 56px;
Â  Â  background: var(--text-main);
Â  Â  color: white;
Â  Â  border-radius: 50%;
Â  Â  display: flex;
Â  Â  align-items: center;
Â  Â  justify-content: center;
Â  Â  font-size: 24px;
Â  Â  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
Â  Â  cursor: pointer;
Â  Â  z-index: 100;
Â  Â  transition: transform 0.2s;
Â  }
Â  .fab-toggle:active { transform: scale(0.9); }

Â  @keyframes pulse {
Â  Â  0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
Â  Â  70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
Â  Â  100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
Â  }

Â  /* Media Queries */
Â  @media (max-width: 640px) {
Â  Â  .line { padding: 15px; }
Â  Â  .english { font-size: 1rem; }
Â  Â  .controls { min-width: 70px; }
Â  }
</style>
</head>
<body>

Â  <div id="mdc-header">
Â  Â  <a href="https://paradisonetworx.com/mdceng">MDC ENG</a>
Â  </div>

Â  <div class="page-max-width">
Â  Â Â 
Â  Â  <div class="video-wrapper">
Â  Â  Â  <div class="video-inner">
Â  Â  Â  Â  <div id="player"></div>
Â  Â  Â  Â  Â  Â  Â  Â  <div id="resume-message" style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 12px; display: none;">
Â  Â  Â  Â  Â  Reanudando...
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div class="dialogue-container">
Â  Â  Â Â 
<div class="line" data-time="12">
Â  <div class="line-content">
Â  Â  <div class="text-block">
Â  Â  Â  <div class="english">When I was first learning to meditate,</div>
Â  Â  Â  <div class="spanish">Cuando empecÃ© a aprender a meditar,</div>
Â  Â  </div>
Â  Â  <div class="controls">
Â  Â  Â  <button class="btn playBtn">Play</button>
Â  Â  Â  <button class="btn speakBtn">Speak</button>
Â  Â  </div>
Â  </div>
</div>

Â  Â Â  Â Â 
Â  Â  Â  </div>
Â  </div>

Â  <div class="fab-toggle" onclick="toggleAllTranslations()" title="Ver/Ocultar todas las traducciones">
Â  Â  ğŸ‘ï¸
Â  </div>

<script>
/* ====== CONFIGURACIÃ“N ====== */
// Ajuste fino: Si la frase empieza muy rÃ¡pido, resta 0.5s. Si acaba abruptamente, suma 1.5s
const TIME_OFFSET = -0.2;Â 
const END_PADDING = 0.5;Â 
const YOUTUBE_ID Â = '-moW9jvvMr4'; // CAMBIAR ID AQUÃ
const PROGRESS_STORAGE_KEY = 'mdceng_video_time_' + YOUTUBE_ID; // Clave Ãºnica por video

/* ====== VARIABLES GLOBALES ====== */
let player;
let checkInterval;
let progressSaveInterval; // Nuevo intervalo
let isSegmentPlaying = false;
let segmentEndTime = 0;
let currentSynth = null;
let scrollEnabled = true;

// ====== YOUTUBE API ======
const tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
document.getElementsByTagName('script')[0].parentNode.insertBefore(tag, document.getElementsByTagName('script')[0]);

function onYouTubeIframeAPIReady() {
Â  player = new YT.Player('player', {
Â  Â  videoId: YOUTUBE_ID,
Â  Â  playerVars: {Â 
Â  Â  Â  playsinline: 1,Â 
Â  Â  Â  rel: 0,Â 
Â  Â  Â  modestbranding: 1,
Â  Â  Â  controls: 1
Â  Â  },
Â  Â  events: {
Â  Â  Â  'onReady': onPlayerReady, // Llamada al cargar el video
Â  Â  Â  'onStateChange': onPlayerStateChange
Â  Â  }
Â  });
}

// FunciÃ³n que se ejecuta cuando el reproductor estÃ¡ listo
function onPlayerReady(event) {
Â  loadProgress();
Â  
Â  // Iniciar guardado automÃ¡tico de progreso cada 5 segundos
Â  progressSaveInterval = setInterval(saveProgress, 5000);
}

/* ====== LÃ“GICA DE PERSISTENCIA (AÃ‘ADIDA) ====== */

/**
 * Guarda el tiempo de reproducciÃ³n actual en el localStorage.
 */
function saveProgress() {
Â  if (player && player.getCurrentTime) {
Â  Â  const currentTime = player.getCurrentTime();
Â  Â  // Solo guardamos si el tiempo es mayor a 5 segundos (evitar guardar el inicio)
Â  Â  if (currentTime > 5) {
Â  Â  Â  localStorage.setItem(PROGRESS_STORAGE_KEY, Math.floor(currentTime));
Â  Â  Â  console.log('Progreso guardado: ' + Math.floor(currentTime) + 's');
Â  Â  }
Â  }
}

/**
 * Carga el tiempo de reproducciÃ³n guardado y salta a ese punto.
 */
function loadProgress() {
Â  const savedTime = localStorage.getItem(PROGRESS_STORAGE_KEY);
Â  const resumeMessage = document.getElementById('resume-message');

Â  if (savedTime) {
Â  Â  const time = parseInt(savedTime, 10);
Â  Â  
Â  Â  // Solo saltar si el tiempo es razonable (ej. mÃ¡s de 5 segundos)
Â  Â  if (time > 5) {
Â  Â  Â  player.seekTo(time, true);
Â  Â  Â  highlightCurrentLine(time); // Resaltar lÃ­nea cargada
Â  Â  Â  
Â  Â  Â  // Mostrar mensaje de reanudaciÃ³n
Â  Â  Â  resumeMessage.style.display = 'block';
Â  Â  Â  resumeMessage.textContent = `Reanudando en ${new Date(time * 1000).toISOString().substr(14, 5)}`;
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  resumeMessage.style.display = 'none';
Â  Â  Â  }, 3000);
Â  Â  Â  
Â  Â  Â  console.log('Progreso cargado y reanudado en: ' + time + 's');
Â  Â  }
Â  }
}

// Guardar progreso al intentar salir de la pÃ¡gina
window.addEventListener('beforeunload', saveProgress);

/* ====== LÃ“GICA PRINCIPAL (Heartbeat) ====== */
// Esta funciÃ³n se ejecuta cada 100ms cuando el video corre
function checkTime() {
Â  if (!player || !player.getCurrentTime) return;
Â Â 
Â  const currentTime = player.getCurrentTime();

Â  // 1. Control de Segmento (Play Button)
Â  // AquÃ­ estÃ¡ la MAGIA: Si estamos reproduciendo un segmento, verificamos el tiempo actual.
Â  // No usamos setTimeout, asÃ­ que si hay buffering, espera.
Â  if (isSegmentPlaying && currentTime >= segmentEndTime) {
Â  Â  player.pauseVideo();
Â  Â  isSegmentPlaying = false;
Â  Â  resetButtons(); // Solo resetea los textos de los botones ("Stop" -> "Play")
Â  Â  scrollEnabled = true; // Reactivar scroll automÃ¡tico global
Â  Â  return;Â 
Â  }

Â  // 2. Resaltado AutomÃ¡tico (Scroll)
Â  if (scrollEnabled) {
Â  Â  highlightCurrentLine(currentTime);
Â  }
}

function onPlayerStateChange(event) {
Â  if (event.data === YT.PlayerState.PLAYING) {
Â  Â  // Iniciar el monitor de tiempo
Â  Â  clearInterval(checkInterval);
Â  Â  checkInterval = setInterval(checkTime, 100);
Â  } else {
Â  Â  clearInterval(checkInterval);
Â  }
}

/* ====== MANEJO DE DOM ====== */

// Resaltar lÃ­nea actual basada en el tiempo
function highlightCurrentLine(time) {
Â  const lines = document.querySelectorAll('.line');
Â  let activeLine = null;

Â  lines.forEach((line, index) => {
Â  Â  const start = parseFloat(line.dataset.time);
Â  Â  // El fin es el inicio de la siguiente lÃ­nea, o +10s si es la Ãºltima
Â  Â  const nextLine = lines[index + 1];
Â  Â  const end = nextLine ? parseFloat(nextLine.dataset.time) : start + 10;

Â  Â  if (time >= start && time < end) {
Â  Â  Â  activeLine = line;
Â  Â  }
Â  Â  line.classList.remove('active');
Â  });

Â  if (activeLine) {
Â  Â  activeLine.classList.add('active');
Â  Â  scrollToLine(activeLine);
Â  }
}

function scrollToLine(element) {
Â  // Obtiene la posiciÃ³n y dimensiones del elemento
Â  const rect = element.getBoundingClientRect();
Â Â 
Â  // Calcula el centro vertical del elemento
Â  const elementCenter = rect.top + rect.height / 2;
Â Â 
Â  // Calcula el centro vertical de la ventana visible (viewport)
Â  const screenCenter = window.innerHeight / 2;
Â Â 
Â  // Calcula el desplazamiento necesario para mover el centro del elemento al centro de la pantalla.
Â  const offsetPosition = window.pageYOffset + elementCenter - screenCenter - 40;Â 
Â Â 
Â  // Se realiza el scroll suave
Â  window.scrollTo({
Â  Â  top: offsetPosition,
Â  Â  behavior: "smooth"
Â  });
}

/* ====== BOTONES PLAY (SEGMENTOS) ====== */
document.querySelectorAll('.playBtn').forEach(btn => {
Â  btn.addEventListener('click', (e) => {
Â  Â  e.stopPropagation(); // Evitar abrir traducciÃ³n
Â  Â  const line = btn.closest('.line');
Â  Â  const start = parseFloat(line.dataset.time) + TIME_OFFSET;
Â  Â Â 
Â  Â  // Calcular fin basado en la siguiente lÃ­nea
Â  Â  const nextLine = line.nextElementSibling;
Â  Â  const nextTime = nextLine ? parseFloat(nextLine.dataset.time) : start + 5;
Â  Â  const end = nextTime + END_PADDING;

Â  Â  // Si ya estÃ¡ sonando este botÃ³n, paramos
Â  Â  if (btn.dataset.state === 'playing') {
Â  Â  Â  player.pauseVideo();
Â  Â  Â  isSegmentPlaying = false;
Â  Â  Â  resetButtons();
Â  Â  Â  return;
Â  Â  }

Â  Â  // Iniciar reproducciÃ³n
Â  Â  resetButtons(); // Limpiar otros botones
Â  Â  resetSynth(); Â  // Calla la voz sintÃ©tica si habla
Â  Â  clearActiveLines(); // ğŸ’¡ CORRECCIÃ“N: Deselecciona la lÃ­nea anterior
Â  Â Â 
Â  Â  scrollEnabled = false; // Desactivar scroll auto para que no salte
Â  Â  isSegmentPlaying = true;
Â  Â  segmentEndTime = end;
Â  Â Â 
Â  Â  player.seekTo(Math.max(0, start), true);
Â  Â  player.playVideo();
Â  Â Â 
Â  Â  btn.textContent = "Stop";
Â  Â  btn.dataset.state = 'playing';
Â  Â  line.classList.add('active'); // Activa la nueva lÃ­nea
Â  });
});

/* ====== BOTONES SPEAK (TTS MEJORADO) ====== */
// Cargar voces
let voices = [];
window.speechSynthesis.onvoiceschanged = () => {
Â  voices = window.speechSynthesis.getVoices();
};

document.querySelectorAll('.speakBtn').forEach(btn => {
Â  btn.addEventListener('click', (e) => {
Â  Â  e.stopPropagation();
Â  Â  const line = btn.closest('.line');
Â  Â  const text = line.querySelector('.english').innerText;

Â  Â  if (btn.dataset.state === 'speaking') {
Â  Â  Â  resetSynth();
Â  Â  Â  resetButtons();
Â  Â  Â  return;
Â  Â  }

Â  Â  resetButtons();
Â  Â  resetSynth();
Â  Â  player.pauseVideo(); // Callar video si suena

Â  Â  const utter = new SpeechSynthesisUtterance(text);
Â  Â Â 
Â  Â  // Intentar buscar una voz mejor (Google US o Samantha)
Â  Â  const preferredVoice = voices.find(v =>Â 
Â  Â  Â  v.name.includes('Google US English') ||Â 
Â  Â  Â  v.name.includes('Samantha') ||Â 
Â  Â  Â  v.lang === 'en-US'
Â  Â  );
Â  Â Â 
Â  Â  if (preferredVoice) utter.voice = preferredVoice;
Â  Â  utter.lang = 'en-US';
Â  Â  utter.rate = 0.65; // Un poco mÃ¡s lento para claridad

Â  Â  utter.onstart = () => {
Â  Â  Â  btn.textContent = "Stop";
Â  Â  Â  btn.dataset.state = 'speaking';
Â  Â  Â  clearActiveLines(); // ğŸ’¡ CORRECCIÃ“N: Deselecciona la lÃ­nea anterior
Â  Â  Â  line.classList.add('active'); // Activa la nueva lÃ­nea
Â  Â  };
Â  Â Â 
Â  Â  utter.onend = () => {
Â  Â  Â  resetButtons();
Â  Â  };

Â  Â  window.speechSynthesis.speak(utter);
Â  });
});

/* ====== UTILIDADES ====== */

// FunciÃ³n auxiliar para quitar la selecciÃ³n de todas las lÃ­neas.
function clearActiveLines() {
Â  document.querySelectorAll('.line.active').forEach(line => {
Â  Â  line.classList.remove('active');
Â  });
}

function resetButtons() {
Â  document.querySelectorAll('.playBtn').forEach(b => {
Â  Â  b.textContent = "Play";
Â  Â  b.removeAttribute('data-state');
Â  });
Â  document.querySelectorAll('.speakBtn').forEach(b => {
Â  Â  b.textContent = "Speak";
Â  Â  b.removeAttribute('data-state');
Â  });
Â  // No se toca la clase 'active' aquÃ­, lo que garantiza que la lÃ­nea se mantenga seleccionada al finalizar el Play.
}

function resetSynth() {
Â  window.speechSynthesis.cancel();
}

// Toggle de traducciÃ³n individual
document.querySelectorAll('.text-block').forEach(block => {
Â  block.addEventListener('click', () => {
Â  Â  const span = block.querySelector('.spanish');
Â  Â  span.classList.toggle('visible');
Â  });
});

// Toggle global (BotÃ³n Flotante)
let allVisible = false;
function toggleAllTranslations() {
Â  allVisible = !allVisible;
Â  document.querySelectorAll('.spanish').forEach(span => {
Â  Â  if (allVisible) span.classList.add('visible');
Â  Â  else span.classList.remove('visible');
Â  });
}
</script>
</body>
</html>
